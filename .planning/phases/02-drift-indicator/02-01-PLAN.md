---
phase: 02-drift-indicator
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/model.rs
  - src/mise.rs
autonomous: true
requirements:
  - DRFT-01
  - DRFT-02

must_haves:
  truths:
    - "DriftState enum exists with variants: Checking, Healthy, Drifted, Missing, NoConfig"
    - "mise.rs exports check_cwd_drift() which shells out to `mise status` and maps output to DriftState"
    - "notify crate is added to Cargo.toml and compiles successfully"
  artifacts:
    - path: "src/model.rs"
      provides: "DriftState enum (Checking, Healthy, Drifted, Missing, NoConfig)"
      contains: "pub enum DriftState"
    - path: "src/mise.rs"
      provides: "check_cwd_drift() async function"
      exports: ["check_cwd_drift"]
    - path: "Cargo.toml"
      provides: "notify dependency"
      contains: "notify"
  key_links:
    - from: "src/mise.rs"
      to: "src/model.rs"
      via: "DriftState import"
      pattern: "use crate::model::DriftState"
---

<objective>
Add the data foundation for Phase 2: the `DriftState` enum representing all possible CWD health states, a `check_cwd_drift()` async function that inspects the CWD via `mise status`, and the `notify` crate in Cargo.toml for filesystem watching in Plan 03.

Purpose: All subsequent plans depend on these types and this function. Isolating them in Wave 1 lets Plans 02 and 03 proceed in parallel.
Output: `DriftState` type in `src/model.rs`, `check_cwd_drift()` in `src/mise.rs`, `notify` crate added to `Cargo.toml`.
</objective>

<execution_context>
@/home/ihsen/.claude/get-shit-done/workflows/execute-plan.md
@/home/ihsen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/model.rs
@src/mise.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add DriftState enum to src/model.rs</name>
  <files>src/model.rs</files>
  <action>
Append `DriftState` enum to the bottom of `src/model.rs`. Do NOT modify existing types.

```rust
/// Health state of the current working directory's tool requirements.
/// Checking = async check in flight; Healthy = all tools present and correct version;
/// Drifted = at least one tool version mismatch; Missing = at least one tool not installed;
/// NoConfig = no .mise.toml or global config applies to CWD.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DriftState {
    Checking,
    Healthy,
    Drifted,
    Missing,
    NoConfig,
}
```

Add `#[derive(Debug, Clone, Copy, PartialEq, Eq)]` — no Deserialize needed (this is not deserialized from JSON).
  </action>
  <verify>
    <automated>cd /home/ihsen/Documents/repos/misetui && cargo check 2>&1 | head -20</automated>
    <manual>src/model.rs contains `pub enum DriftState` with all 5 variants</manual>
  </verify>
  <done>DriftState enum compiles without warnings; all 5 variants present</done>
</task>

<task type="auto">
  <name>Task 2: Add check_cwd_drift() to src/mise.rs and notify to Cargo.toml</name>
  <files>src/mise.rs, Cargo.toml</files>
  <action>
**Cargo.toml:** Add `notify = { version = "6", features = ["macos_fsevent"] }` under `[dependencies]`. The `macos_fsevent` feature is the recommended backend for macOS; on Linux notify uses inotify automatically. Use version 6 (current stable, async-friendly via notify::recommended_watcher with a std channel bridged to tokio).

**src/mise.rs:** Add `check_cwd_drift()` at the end of the file.

Import at top of file (add to existing imports):
```rust
use crate::model::DriftState;
use std::env;
```

Function logic — run `mise status --json` (or `mise status` plain text if JSON not available). The command `mise status` outputs lines like:
```
node  20.0.0  20.11.0  ~/.mise.toml
```
Exit code 0 = tools present, non-zero OR "no config" message = no-config / missing.

Use plain text parsing since `mise status` JSON is not stable across versions:

```rust
pub async fn check_cwd_drift() -> Result<DriftState, String> {
    // `mise status` exits 0 if all tools installed and matching,
    // non-zero if any are missing/drifted.
    // When no config applies, stderr contains "no config file found" or stdout is empty.
    let output = Command::new("mise")
        .args(["status"])
        .output()
        .await
        .map_err(|e| format!("Failed to run mise status: {e}"))?;

    let stdout = String::from_utf8_lossy(&output.stdout).to_string();
    let stderr = String::from_utf8_lossy(&output.stderr).to_string();

    // No config: mise prints nothing or "no config" message
    if stdout.trim().is_empty() && stderr.trim().is_empty() {
        return Ok(DriftState::NoConfig);
    }

    if stderr.to_lowercase().contains("no config") || stderr.to_lowercase().contains("not found") {
        return Ok(DriftState::NoConfig);
    }

    if !output.status.success() {
        // Non-zero exit means a tool is missing or drifted — check stderr for "missing"
        if stderr.to_lowercase().contains("missing") || stdout.to_lowercase().contains("missing") {
            return Ok(DriftState::Missing);
        }
        return Ok(DriftState::Drifted);
    }

    // Exit 0 — check output for any lines showing version mismatch
    // mise status prints lines: `tool  requested  installed  source`
    // If installed != requested it would have been a non-zero exit,
    // but double-check: if "missing" appears in stdout, treat as Missing.
    if stdout.to_lowercase().contains("missing") {
        return Ok(DriftState::Missing);
    }

    Ok(DriftState::Healthy)
}
```

Note: `mise status` behavior may vary by mise version. This implementation is conservative: trust the exit code as the primary signal, use stdout/stderr content only as a tiebreaker for Missing vs Drifted. If `mise status` is unavailable in the user's version, the error propagates and the caller can set `DriftState::NoConfig` as a fallback.
  </action>
  <verify>
    <automated>cd /home/ihsen/Documents/repos/misetui && cargo check 2>&1 | head -30</automated>
    <manual>Cargo.toml has notify = "6", src/mise.rs compiles with check_cwd_drift exported</manual>
  </verify>
  <done>`cargo check` passes with 0 errors; `notify` crate resolves; `check_cwd_drift` is `pub async fn` returning `Result&lt;DriftState, String&gt;`</done>
</task>

</tasks>

<verification>
Run `cargo check` from the project root — must pass with zero errors.
DriftState enum is in src/model.rs and imported correctly in src/mise.rs.
Cargo.toml lists `notify = { version = "6", ... }`.
</verification>

<success_criteria>
- `cargo check` exits 0
- `src/model.rs` contains `pub enum DriftState` with Checking, Healthy, Drifted, Missing, NoConfig variants
- `src/mise.rs` exports `pub async fn check_cwd_drift() -> Result<DriftState, String>`
- `Cargo.toml` lists notify v6 dependency
</success_criteria>

<output>
After completion, create `.planning/phases/02-drift-indicator/02-01-SUMMARY.md` using the summary template.
</output>
