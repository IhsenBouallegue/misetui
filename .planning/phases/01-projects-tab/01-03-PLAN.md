---
phase: 01-projects-tab
plan: 03
type: execute
wave: 3
depends_on:
  - 01-02
files_modified:
  - src/ui/projects.rs
  - src/ui/mod.rs
  - src/ui/sidebar.rs
autonomous: true
requirements:
  - PROJ-01
  - PROJ-03
  - PROJ-06

must_haves:
  truths:
    - "Projects tab renders a list of projects with name, path, tool count, and health status badge"
    - "Selecting a project and pressing Enter shows a per-tool drill-down with required vs installed version and health status"
    - "Pressing Escape or Enter again exits the drill-down back to the project list"
    - "Fuzzy search bar appears when / is active and filters the project list"
    - "While data loads, a spinner is shown instead of the project list"
  artifacts:
    - path: "src/ui/projects.rs"
      provides: "Projects tab renderer with list view and drill-down sub-view"
      contains: "pub fn render"
    - path: "src/ui/mod.rs"
      provides: "Tab::Projects dispatch to projects::render"
      contains: "Tab::Projects"
    - path: "src/ui/sidebar.rs"
      provides: "Sidebar renders 9 tabs including Projects"
      contains: "Tab::ALL"
  key_links:
    - from: "src/ui/mod.rs"
      to: "src/ui/projects.rs"
      via: "Tab::Projects => projects::render(f, layout.content, app)"
      pattern: "Tab::Projects => projects"
    - from: "src/ui/projects.rs"
      to: "src/app.rs"
      via: "app.filtered_projects, app.projects_hl, app.projects_drill_active, app.projects[idx].tools"
      pattern: "filtered_projects"
---

<objective>
Create the Projects tab renderer with list view and tool drill-down.

Purpose: The data and state are wired after plans 01-02. This plan adds the visual layer: the project list table, search bar, health status badges with color coding, and the drill-down sub-view showing per-tool health.

Output:
- `src/ui/projects.rs` — full renderer for list view + drill-down
- `src/ui/mod.rs` — Tab::Projects dispatch added
- `src/ui/sidebar.rs` — automatically works if Tab::ALL has 9 entries (verify; may need no change)
</objective>

<execution_context>
@/home/ihsen/.claude/get-shit-done/workflows/execute-plan.md
@/home/ihsen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@src/ui/mod.rs
@src/ui/tools.rs
@src/ui/sidebar.rs
@src/app.rs
@src/theme.rs
@src/model.rs
@.planning/phases/01-projects-tab/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Tab::Projects dispatch to ui/mod.rs and verify sidebar</name>
  <files>src/ui/mod.rs, src/ui/sidebar.rs</files>
  <action>
    ## src/ui/mod.rs

    1. Add `mod projects;` to the module declarations at the top (alongside existing `mod config`, `mod doctor`, etc.)
    2. Add `Tab::Projects` arm to the render match block:
    ```rust
    Tab::Projects => projects::render(f, layout.content, app),
    ```
    Place it between `Tab::Config` and `Tab::Doctor` arms to match the tab ordering.

    ## src/ui/sidebar.rs

    Read the current sidebar.rs to understand how it renders tabs. The sidebar iterates over `Tab::ALL`. Since Tab::ALL now has 9 entries and Tab::Projects has a label() implementation, the sidebar should render automatically without changes. Verify by reading sidebar.rs — if it uses `Tab::ALL` to iterate and calls `.label()`, no change is needed. If it has hardcoded tab counts or special-cases Doctor index, update accordingly.

    If sidebar.rs has a fixed-width or fixed-count assumption, update to accommodate 9 tabs. The sidebar is typically 16 characters wide (see layout.rs) which is sufficient for all labels.
  </action>
  <verify>
    <automated>cargo build 2>&1 | grep -E "^error" | head -20</automated>
    <manual>Verify mod.rs has `mod projects;` and the Tab::Projects dispatch arm. Check sidebar.rs compiles correctly for 9 tabs.</manual>
  </verify>
  <done>cargo build succeeds. ui/mod.rs dispatches Tab::Projects to projects::render. The sidebar renders all 9 tabs.</done>
</task>

<task type="auto">
  <name>Task 2: Create projects tab renderer with list and drill-down views</name>
  <files>src/ui/projects.rs</files>
  <action>
    Create `src/ui/projects.rs` following the exact same patterns as `src/ui/tools.rs` (search bar, loading spinner, empty state, table). The renderer has two modes controlled by `app.projects_drill_active`:

    **Mode 1 — Project List (projects_drill_active = false):**
    - Show search bar if search_active (same pattern as tools.rs)
    - Show loading spinner if projects_state == LoadState::Loading
    - Show empty state if no projects found
    - Table with columns: Name (highlight_cached), Path (truncated to 30 chars), Tools (count), Health (colored badge)
    - Selected row highlighted with theme::table_selected()
    - Footer hint: `Enter=drill-down  i=install  u=update  /=search  r=rescan`

    **Mode 2 — Tool Drill-Down (projects_drill_active = true):**
    - Title: `" Project: {project.name} — {project.path} "`
    - Table with columns: Tool, Required, Installed, Status
    - Health status badge colored: Healthy=GREEN, Outdated=YELLOW, Missing=RED
    - Row highlight at projects_drill_selected
    - Footer hint: `Enter/Esc=back  j/k=navigate`
    - If project has no tools declared, show "No tools declared in .mise.toml"

    **Health badge coloring** for the list view health column:
    - `ProjectHealthStatus::Healthy` → theme::GREEN (or active_indicator style)
    - `ProjectHealthStatus::Outdated` → theme::YELLOW (yellow style)
    - `ProjectHealthStatus::Missing` → theme::RED (error style)
    - `ProjectHealthStatus::NoConfig` → theme::MUTED

    ```rust
    use super::highlight::highlight_cached;
    use crate::app::{App, LoadState};
    use crate::model::ProjectHealthStatus;
    use crate::theme;
    use ratatui::layout::{Constraint, Direction, Layout, Rect};
    use ratatui::style::{Color, Style};
    use ratatui::text::{Line, Span};
    use ratatui::widgets::{Block, BorderType, Borders, Cell, Paragraph, Row, Table, TableState};
    use ratatui::Frame;

    pub fn render(f: &mut Frame, area: Rect, app: &App) {
        if app.projects_drill_active {
            render_drill_down(f, area, app);
        } else {
            render_list(f, area, app);
        }
    }

    fn health_style(status: &ProjectHealthStatus) -> Style {
        match status {
            ProjectHealthStatus::Healthy  => Style::default().fg(theme::GREEN),
            ProjectHealthStatus::Outdated => Style::default().fg(theme::YELLOW),
            ProjectHealthStatus::Missing  => Style::default().fg(theme::RED),
            ProjectHealthStatus::NoConfig => theme::muted(),
        }
    }

    fn render_list(f: &mut Frame, area: Rect, app: &App) {
        let chunks = if app.search_active {
            Layout::default()
                .direction(Direction::Vertical)
                .constraints([Constraint::Length(3), Constraint::Min(3)])
                .split(area)
        } else {
            Layout::default()
                .direction(Direction::Vertical)
                .constraints([Constraint::Length(0), Constraint::Min(3)])
                .split(area)
        };

        if app.search_active {
            let search_block = Block::default()
                .title(Span::styled(" Search ", theme::title()))
                .borders(Borders::ALL)
                .border_type(BorderType::Rounded)
                .border_style(theme::border_focused())
                .style(Style::default().bg(theme::SURFACE));
            let search = Paragraph::new(Line::from(vec![
                Span::styled("/", theme::key_hint()),
                Span::styled(&app.search_query, theme::search_input()),
                Span::styled("█", theme::search_input()),
            ]))
            .block(search_block);
            f.render_widget(search, chunks[0]);
        }

        let content_area = chunks[1];
        let count = app.filtered_projects.len();
        let total = app.projects.len();
        let title = if app.search_active && !app.search_query.is_empty() {
            format!(" Projects ({count}/{total}) ")
        } else {
            format!(" Projects ({total}) ")
        };

        let block = Block::default()
            .title(Span::styled(title, theme::title()))
            .borders(Borders::ALL)
            .border_type(BorderType::Rounded)
            .border_style(theme::border_focused())
            .style(Style::default().bg(theme::BG));

        if app.projects_state == LoadState::Loading {
            let spinner = app.spinner_char();
            let loading = Paragraph::new(format!("  {spinner} Scanning projects..."))
                .style(theme::muted())
                .block(block);
            f.render_widget(loading, content_area);
            return;
        }

        if app.filtered_projects.is_empty() {
            let msg = if app.search_active && !app.search_query.is_empty() {
                "  No matching projects"
            } else {
                "  No projects found — check ~/.config/misetui/config.toml scan_dirs"
            };
            let empty = Paragraph::new(msg).style(theme::muted()).block(block);
            f.render_widget(empty, content_area);
            return;
        }

        let header = Row::new(vec![
            Cell::from("Name"),
            Cell::from("Path"),
            Cell::from("Tools"),
            Cell::from("Health"),
        ])
        .style(theme::table_header());

        let rows: Vec<Row> = app.filtered_projects
            .iter()
            .enumerate()
            .map(|(i, &idx)| {
                let proj = &app.projects[idx];
                let name_hl = app.projects_hl.get(i).map(|v| v.as_slice()).unwrap_or(&[]);

                // Truncate path to last 3 components for readability
                let path_display = {
                    let parts: Vec<&str> = proj.path.split('/').collect();
                    let shown = &parts[parts.len().saturating_sub(3)..];
                    format!("…/{}", shown.join("/"))
                };

                Row::new(vec![
                    Cell::from(highlight_cached(&proj.name, name_hl, theme::table_row())),
                    Cell::from(Span::styled(path_display, theme::muted())),
                    Cell::from(Span::styled(proj.tool_count.to_string(), theme::table_row())),
                    Cell::from(Span::styled(proj.health.label(), health_style(&proj.health))),
                ])
            })
            .collect();

        let widths = [
            Constraint::Length(20),
            Constraint::Min(20),
            Constraint::Length(6),
            Constraint::Length(12),
        ];

        let table = Table::new(rows, widths)
            .header(header)
            .block(block)
            .row_highlight_style(theme::table_selected());

        let mut state = TableState::default();
        state.select(Some(app.projects_selected));
        f.render_stateful_widget(table, content_area, &mut state);
    }

    fn render_drill_down(f: &mut Frame, area: Rect, app: &App) {
        // Get the selected project
        let Some(&idx) = app.filtered_projects.get(app.projects_selected) else {
            return;
        };
        let proj = &app.projects[idx];

        let title = format!(" {} — Tool Health ", proj.name);
        let block = Block::default()
            .title(Span::styled(title, theme::title()))
            .borders(Borders::ALL)
            .border_type(BorderType::Rounded)
            .border_style(theme::border_focused())
            .style(Style::default().bg(theme::BG));

        if proj.tools.is_empty() {
            let msg = format!("  No tools declared in .mise.toml\n  Path: {}", proj.path);
            let empty = Paragraph::new(msg).style(theme::muted()).block(block);
            f.render_widget(empty, area);
            return;
        }

        let header = Row::new(vec![
            Cell::from("Tool"),
            Cell::from("Required"),
            Cell::from("Installed"),
            Cell::from("Status"),
        ])
        .style(theme::table_header());

        let rows: Vec<Row> = proj.tools
            .iter()
            .map(|tool_health| {
                let installed_text = if tool_health.installed.is_empty() {
                    "not installed"
                } else {
                    &tool_health.installed
                };
                Row::new(vec![
                    Cell::from(Span::styled(&tool_health.tool[..], theme::table_row())),
                    Cell::from(Span::styled(&tool_health.required[..], theme::muted())),
                    Cell::from(Span::styled(installed_text, theme::table_row())),
                    Cell::from(Span::styled(
                        tool_health.status.label(),
                        health_style(&tool_health.status),
                    )),
                ])
            })
            .collect();

        let widths = [
            Constraint::Length(16),
            Constraint::Length(14),
            Constraint::Length(14),
            Constraint::Length(12),
        ];

        let table = Table::new(rows, widths)
            .header(header)
            .block(block)
            .row_highlight_style(theme::table_selected());

        let mut state = TableState::default();
        state.select(Some(app.projects_drill_selected));
        f.render_stateful_widget(table, area, &mut state);
    }
    ```

    Note: Use `theme::GREEN`, `theme::YELLOW`, `theme::RED` constants directly (they are `ratatui::style::Color` values, apply with `Style::default().fg(...)`). Check `src/theme.rs` for the exact constant names — the codebase defines them as `pub const GREEN: Color = Color::Rgb(...)`.
  </action>
  <verify>
    <automated>cargo build 2>&1 | grep -E "^error" | head -20</automated>
    <manual>Run `cargo run`. Navigate to the Projects tab (it should be between Config and Doctor in the sidebar). Verify the list renders or shows "Scanning projects..." then transitions to showing discovered projects (or the empty state message).</manual>
  </verify>
  <done>cargo build succeeds. src/ui/projects.rs exists with render(), render_list(), render_drill_down(), and health_style() functions. The app runs and shows the Projects tab in the sidebar.</done>
</task>

</tasks>

<verification>
Run `cargo run` and verify:
1. Projects tab appears in sidebar between Config and Doctor
2. Navigating to it shows either spinner or project list
3. If any directories contain .mise.toml files, they appear with health status colored correctly
4. Pressing / activates search and filters the project list
5. `cargo build` exits 0 with no compilation errors
</verification>

<success_criteria>
- `cargo build` exits 0
- `src/ui/projects.rs` exists with both render_list() and render_drill_down() functions
- `src/ui/mod.rs` dispatches Tab::Projects to projects::render
- App runs without panic when navigating to Projects tab
- Health status labels show with correct colors (green/yellow/red)
</success_criteria>

<output>
After completion, create `.planning/phases/01-projects-tab/01-03-SUMMARY.md` following the summary template.
</output>
