---
phase: 03-bootstrap-wizard
plan: 03
type: execute
wave: 3
depends_on:
  - 03-02
files_modified:
  - src/ui/wizard.rs
  - src/ui/popup.rs
  - src/ui/mod.rs
  - src/ui/footer.rs
autonomous: false
requirements:
  - BOOT-01
  - BOOT-02
  - BOOT-03
  - BOOT-04
  - BOOT-05
  - BOOT-06
  - BOOT-07

must_haves:
  truths:
    - "Pressing B opens a wizard popup — user sees spinner while detecting"
    - "Review step shows a numbered list of detected tools, each with name/version/source; selected row is highlighted; Space toggles enabled/disabled"
    - "A toggle row for agent files (AGENTS.md + CLAUDE.md) is visible at the bottom of Review step"
    - "Preview step shows the generated .mise.toml content in a scrollable paragraph"
    - "Writing step shows a spinner message while mise install runs"
    - "Help text updated to document B keybinding"
  artifacts:
    - path: "src/ui/wizard.rs"
      provides: "pub fn render_wizard(f, wizard) — renders all four WizardStep states"
      min_lines: 80
      contains: "pub fn render_wizard"
    - path: "src/ui/popup.rs"
      provides: "Popup::Wizard arm dispatches to render_wizard"
      contains: "Popup::Wizard"
    - path: "src/ui/mod.rs"
      provides: "wizard module declared"
      contains: "mod wizard"
    - path: "src/ui/footer.rs"
      provides: "B key hint added to footer or help text updated"
  key_links:
    - from: "src/ui/popup.rs"
      to: "src/ui/wizard.rs"
      via: "render_wizard call in Popup::Wizard match arm"
      pattern: "render_wizard"
    - from: "src/ui/wizard.rs"
      to: "src/model.rs"
      via: "WizardState, WizardStep, DetectedTool imported and rendered"
      pattern: "WizardState"
---

<objective>
Implement the Bootstrap Wizard UI renderer: four-step visual flow (Detecting/Review/Preview/Writing) and footer/help text update.

Purpose: Makes the wizard visible and usable — without this plan the feature is wired but invisible.
Output: src/ui/wizard.rs renderer, popup.rs Wizard arm, mod.rs declaration, footer B hint.
</objective>

<execution_context>
@/home/ihsen/.claude/get-shit-done/workflows/execute-plan.md
@/home/ihsen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-bootstrap-wizard/03-02-SUMMARY.md
@src/ui/popup.rs
@src/ui/mod.rs
@src/ui/footer.rs
@src/model.rs
@src/app.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create src/ui/wizard.rs renderer and wire into popup.rs and mod.rs</name>
  <files>src/ui/wizard.rs, src/ui/popup.rs, src/ui/mod.rs</files>
  <action>
**src/ui/wizard.rs** — Create this new file implementing the wizard renderer. Follow the same style as popup.rs (use centered_rect via re-import or inline, use theme::* for styles).

```rust
use crate::model::{DetectedTool, WizardState, WizardStep};
use crate::theme;
use ratatui::layout::{Constraint, Layout};
use ratatui::text::{Line, Span};
use ratatui::widgets::{
    Block, BorderType, Borders, Clear, List, ListItem, ListState, Paragraph, Wrap,
};
use ratatui::Frame;
use ratatui::layout::Rect;

/// Centered rect helper (mirrors popup.rs — cannot import from there due to module visibility).
fn centered_rect(width: u16, height: u16, area: Rect) -> Rect {
    let x = area.x + area.width.saturating_sub(width) / 2;
    let y = area.y + area.height.saturating_sub(height) / 2;
    Rect::new(x, y, width.min(area.width), height.min(area.height))
}

/// Top-level render entry point — dispatches by wizard step.
pub fn render_wizard(f: &mut Frame, wizard: &WizardState) {
    match wizard.step {
        WizardStep::Detecting => render_detecting(f, &wizard.target_dir),
        WizardStep::Review => render_review(f, wizard),
        WizardStep::Preview => render_preview(f, wizard),
        WizardStep::Writing => render_writing(f, &wizard.target_dir),
    }
}

/// Detecting step: centered spinner popup.
fn render_detecting(f: &mut Frame, target: &str) {
    let area = centered_rect(54, 6, f.area());
    f.render_widget(Clear, area);

    let short_target = shorten_path(target, 30);
    let block = Block::default()
        .title(Span::styled(" Bootstrap Wizard ", theme::title()))
        .borders(Borders::ALL)
        .border_type(BorderType::Rounded)
        .border_style(theme::popup_border())
        .style(theme::popup_bg());

    let text = vec![
        Line::default(),
        Line::from(Span::styled(
            format!("  Detecting project tools in {short_target}..."),
            theme::progress(),
        )),
        Line::from(Span::styled(
            "  (reading filesystem indicators and legacy pin files)",
            theme::muted(),
        )),
    ];

    let paragraph = Paragraph::new(text).block(block);
    f.render_widget(paragraph, area);
}

/// Review step: scrollable list of detected tools with toggle support.
fn render_review(f: &mut Frame, wizard: &WizardState) {
    // Height: border(2) + header(2) + tools + agent toggle + blank + hints
    let tool_count = wizard.tools.len().max(1);
    let height = (tool_count as u16 + 9).clamp(14, 30);
    let area = centered_rect(62, height, f.area());
    f.render_widget(Clear, area);

    let short_target = shorten_path(&wizard.target_dir, 28);
    let block = Block::default()
        .title(Span::styled(
            format!(" Bootstrap Wizard — Review ({short_target}) "),
            theme::title(),
        ))
        .borders(Borders::ALL)
        .border_type(BorderType::Rounded)
        .border_style(theme::popup_border())
        .style(theme::popup_bg());

    let inner = block.inner(area);
    f.render_widget(block, area);

    // Layout: header | tool list | blank | agent toggle | blank | hints
    let chunks = Layout::default()
        .direction(ratatui::layout::Direction::Vertical)
        .constraints([
            Constraint::Length(1), // header text
            Constraint::Min(1),    // tool list
            Constraint::Length(1), // blank
            Constraint::Length(1), // agent files toggle
            Constraint::Length(1), // blank
            Constraint::Length(1), // hints
        ])
        .split(inner);

    // Header
    let header = Line::from(vec![
        Span::styled("  Tool", theme::table_header()),
        Span::styled("                 Version", theme::table_header()),
        Span::styled("          Source", theme::table_header()),
    ]);
    f.render_widget(Paragraph::new(header), chunks[0]);

    // Tool list
    if wizard.tools.is_empty() {
        let empty = Paragraph::new(Span::styled(
            "  No tools detected — toggle to add manually (feature coming in Phase 4)",
            theme::muted(),
        ));
        f.render_widget(empty, chunks[1]);
    } else {
        let items: Vec<ListItem> = wizard.tools.iter().map(|t| {
            let check = if t.enabled { "✓" } else { "○" };
            let check_style = if t.enabled { theme::success() } else { theme::muted() };
            let version_display = if t.version.is_empty() { "latest" } else { t.version.as_str() };
            // Show install status from mise ls -J cross-reference (populated by detect_project_tools)
            let inst_indicator = if t.installed { "↓" } else { " " }; // ↓ = already installed
            let inst_style = if t.installed { theme::muted() } else { theme::muted() };
            ListItem::new(Line::from(vec![
                Span::styled(format!("  {check} "), check_style),
                Span::styled(format!("{:<16}", t.name), theme::table_row()),
                Span::styled(format!("{:<16}", version_display), theme::muted()),
                Span::styled(format!("  {inst_indicator} "), inst_style),
                Span::styled(t.source.as_str(), theme::muted()),
            ]))
        }).collect();

        let list = List::new(items).highlight_style(theme::table_selected());
        let mut state = ListState::default();
        state.select(Some(wizard.selected));
        f.render_stateful_widget(list, chunks[1], &mut state);
    }

    // Agent files toggle
    let agent_check = if wizard.write_agent_files { "✓" } else { "○" };
    let agent_style = if wizard.write_agent_files { theme::success() } else { theme::muted() };
    let agent_toggle = Line::from(vec![
        Span::styled(format!("  {agent_check} "), agent_style),
        Span::styled("Write AGENTS.md + CLAUDE.md", theme::table_row()),
        Span::styled("  (press a to toggle)", theme::muted()),
    ]);
    f.render_widget(Paragraph::new(agent_toggle), chunks[3]);

    // Hints
    let hint = Line::from(vec![
        Span::styled("  j/k", theme::key_hint()),
        Span::styled(" navigate  ", theme::key_desc()),
        Span::styled("Space", theme::key_hint()),
        Span::styled(" toggle tool  ", theme::key_desc()),
        Span::styled("Enter", theme::key_hint()),
        Span::styled(" preview  ", theme::key_desc()),
        Span::styled("Esc", theme::key_hint()),
        Span::styled(" cancel", theme::key_desc()),
    ]);
    f.render_widget(Paragraph::new(hint), chunks[5]);
}

/// Preview step: scrollable generated .mise.toml content.
fn render_preview(f: &mut Frame, wizard: &WizardState) {
    let area = centered_rect(62, 24, f.area());
    f.render_widget(Clear, area);

    let block = Block::default()
        .title(Span::styled(" Bootstrap Wizard — Preview .mise.toml ", theme::title()))
        .borders(Borders::ALL)
        .border_type(BorderType::Rounded)
        .border_style(theme::popup_border())
        .style(theme::popup_bg());

    let inner = block.inner(area);
    f.render_widget(block, area);

    let chunks = Layout::default()
        .direction(ratatui::layout::Direction::Vertical)
        .constraints([
            Constraint::Min(1),    // content
            Constraint::Length(1), // blank
            Constraint::Length(1), // hints
        ])
        .split(inner);

    let lines: Vec<Line> = wizard.preview_content
        .lines()
        .map(|l| Line::from(Span::styled(format!("  {l}"), theme::table_row())))
        .collect();

    let paragraph = Paragraph::new(lines)
        .wrap(Wrap { trim: false })
        .scroll((wizard.preview_scroll as u16, 0));
    f.render_widget(paragraph, chunks[0]);

    let hint = Line::from(vec![
        Span::styled("  j/k", theme::key_hint()),
        Span::styled(" scroll  ", theme::key_desc()),
        Span::styled("p", theme::key_hint()),
        Span::styled(" back  ", theme::key_desc()),
        Span::styled("Enter", theme::key_hint()),
        Span::styled(" write + install  ", theme::key_desc()),
        Span::styled("Esc", theme::key_hint()),
        Span::styled(" cancel", theme::key_desc()),
    ]);
    f.render_widget(Paragraph::new(hint), chunks[2]);
}

/// Writing step: spinner + message while mise install runs.
fn render_writing(f: &mut Frame, target: &str) {
    let area = centered_rect(54, 6, f.area());
    f.render_widget(Clear, area);

    let short_target = shorten_path(target, 30);
    let block = Block::default()
        .title(Span::styled(" Bootstrap Wizard ", theme::title()))
        .borders(Borders::ALL)
        .border_type(BorderType::Rounded)
        .border_style(theme::popup_border())
        .style(theme::popup_bg());

    let text = vec![
        Line::default(),
        Line::from(Span::styled(
            format!("  Writing .mise.toml and running mise install in {short_target}..."),
            theme::progress(),
        )),
    ];

    let paragraph = Paragraph::new(text).block(block);
    f.render_widget(paragraph, area);
}

/// Truncate a path string to at most `max_chars` by keeping the last N components.
fn shorten_path(path: &str, max_chars: usize) -> String {
    if path.len() <= max_chars {
        return path.to_string();
    }
    let parts: Vec<&str> = path.split('/').collect();
    let mut result = String::new();
    for part in parts.iter().rev() {
        let candidate = if result.is_empty() {
            part.to_string()
        } else {
            format!("{part}/{result}")
        };
        if candidate.len() > max_chars {
            break;
        }
        result = candidate;
    }
    format!("…/{result}")
}
```

Note: `theme::success()` may not exist yet. Check src/theme.rs — if it is absent, use `theme::GREEN` color constant directly as done in drift indicator (drift_style pattern from Phase 02). Use:
```rust
use ratatui::style::{Color, Style};
fn success_style() -> Style {
    Style::default().fg(theme::GREEN)  // or whatever the green constant is named in theme.rs
}
```
Read src/theme.rs before writing this file and use the correct existing style functions/constants. Do NOT invent new theme.rs functions — inline the style instead.

**src/ui/popup.rs** — Add the `Popup::Wizard` match arm. In the `match popup` block in the `render` function, add after the `Popup::ScanConfig` arm:

```rust
        Popup::Wizard(wizard_state) => super::wizard::render_wizard(f, wizard_state),
```

Also add the import: The wizard module is a sibling — access it as `super::wizard::render_wizard`.

**src/ui/mod.rs** — Read this file first, then add `mod wizard;` and `pub mod wizard;` (or just `pub(crate) mod wizard;`) alongside the other module declarations.
  </action>
  <verify>
    <automated>cd /home/ihsen/Documents/repos/misetui && cargo check 2>&1 | head -40</automated>
    <manual>Run the binary and press B — wizard popup should appear. Confirm Detecting → Review → Preview → Writing flow by pressing Enter through each step.</manual>
  </verify>
  <done>cargo check passes; src/ui/wizard.rs exists; pressing B shows wizard; Popup::Wizard arm in popup.rs dispatches to render_wizard.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Human verify the complete wizard flow</name>
  <action>
Run `cargo run` from the repo root and manually exercise the wizard:
1. Press B from any tab to open the wizard
2. Wait for the Detecting step to complete (spinner → Review)
3. Navigate with j/k, toggle tools with Space, toggle agent files with a
4. Press Enter to advance to Preview step
5. Press p to go back; press Enter again to trigger write + install
6. Press Esc at various points to confirm cancel works
7. Press ? to confirm help popup mentions B key
  </action>
  <verify>
    <automated>cd /home/ihsen/Documents/repos/misetui && cargo build 2>&1 | tail -5</automated>
    <manual>All four wizard steps render correctly; keybindings work as documented above.</manual>
  </verify>
  <done>Human confirms wizard opens, steps render correctly, toggle/navigation/write work end-to-end.</done>
  <what-built>
Complete Bootstrap Wizard feature:
- B from any tab opens wizard; Detecting spinner → Review step with detected tools list
- Space toggles tools; a toggles agent files toggle; Enter advances to Preview step
- Preview shows generated .mise.toml; Enter writes file + runs mise install in CWD
- AGENTS.md and CLAUDE.md written when toggle is on
- Help popup updated with B keybinding
  </what-built>
  <how-to-verify>
1. Run: `cargo run` from the repo root
2. Press B — wizard should open showing "Detecting project tools..."
3. After detection, Review step appears. Verify:
   - Tools list shows detected tools (or "No tools detected" for a dir with no indicators)
   - j/k navigates the list; Space toggles ✓/○
   - Agent files toggle row visible at bottom
4. Press Enter — Preview step shows .mise.toml content
5. Press p — goes back to Review step
6. Press Esc at any point — wizard closes with no side effects
7. Press ? — help popup should mention B key
8. Run the app from a directory that has a package.json and verify "node" appears in the list
  </how-to-verify>
  <resume-signal>Type "approved" if the wizard looks and behaves correctly, or describe any issues found.</resume-signal>
</task>

</tasks>

<verification>
`cargo check` passes. Visual verification via checkpoint:human-verify above.
</verification>

<success_criteria>
- src/ui/wizard.rs exists with render_wizard() exported
- popup.rs Popup::Wizard arm dispatches to render_wizard
- mod.rs declares wizard module
- All four WizardStep states render without panic
- B keybinding triggers wizard from any tab
- Human approves the visual verification checkpoint
</success_criteria>

<output>
After completion, create `.planning/phases/03-bootstrap-wizard/03-03-SUMMARY.md` following the summary template.
</output>
