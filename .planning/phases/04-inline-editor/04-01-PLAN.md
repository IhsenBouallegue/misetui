---
phase: 04-inline-editor
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/model.rs
  - src/mise.rs
  - src/action.rs
  - src/app.rs
autonomous: true
requirements:
  - EDIT-01
  - EDIT-07
  - EDIT-08

must_haves:
  truths:
    - "EditorState holds parsed tools, env vars, and tasks from a .mise.toml file path"
    - "toml_edit parses a .mise.toml preserving comments and formatting in a Document"
    - "Atomic write function writes EditorState changes back to disk via temp file + rename using toml_edit Document"
    - "User can press 'e' on a config file row in Config tab or Projects tab to open the editor popup"
  artifacts:
    - path: "Cargo.toml"
      provides: "toml_edit dependency"
      contains: "toml_edit"
    - path: "src/model.rs"
      provides: "EditorState, EditorTab, EditorRow, EditorRowStatus types"
      contains: "EditorState"
    - path: "src/mise.rs"
      provides: "parse_config_for_editor() and write_editor_changes() functions"
      contains: "parse_config_for_editor"
    - path: "src/action.rs"
      provides: "Editor action variants (OpenEditor, EditorLoaded, EditorWrite, etc.)"
      contains: "OpenEditor"
    - path: "src/app.rs"
      provides: "Popup::Editor variant and OpenEditor/EditorLoaded handle_action arms"
      contains: "Popup::Editor"
  key_links:
    - from: "src/app.rs"
      to: "src/mise.rs"
      via: "OpenEditor spawns parse_config_for_editor async"
      pattern: "parse_config_for_editor"
    - from: "src/mise.rs"
      to: "toml_edit"
      via: "Document parsing and serialization"
      pattern: "toml_edit::DocumentMut"
---

<objective>
Create the data foundation for the inline TOML editor: model types, parse/write functions using toml_edit for round-trip preservation, Action enum additions, Popup::Editor variant, and the OpenEditor entry point.

Purpose: Establishes all the data types and I/O plumbing that the editor behavior (Plan 02) and UI renderer (Plan 03) will build on. After this plan, pressing 'e' on a config file opens a Popup::Editor loaded with parsed TOML data.

Output: EditorState populated from .mise.toml via toml_edit, atomic write function, Popup::Editor variant visible in app state.
</objective>

<execution_context>
@/home/ihsen/.claude/get-shit-done/workflows/execute-plan.md
@/home/ihsen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-inline-editor/04-CONTEXT.md

@Cargo.toml
@src/model.rs
@src/action.rs
@src/app.rs
@src/mise.rs
@src/main.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add toml_edit dependency and editor model types</name>
  <files>Cargo.toml, src/model.rs</files>
  <action>
1. Add `toml_edit = "0.22"` to Cargo.toml [dependencies] section (alongside existing `toml = "0.8"`). toml_edit provides round-trip TOML parsing that preserves comments and formatting (EDIT-08).

2. In src/model.rs, add these types at the bottom of the file:

```rust
/// Which sub-tab is active inside the inline editor popup.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum EditorTab {
    Tools,
    Env,
    Tasks,
}

/// Change status for a row in the editor.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum EditorRowStatus {
    /// Unchanged from the file on disk.
    Unchanged,
    /// Modified by the user.
    Modified,
    /// Newly added by the user.
    Added,
    /// Marked for deletion.
    Deleted,
}

/// A single editable row in the editor's Tools sub-tab.
#[derive(Debug, Clone)]
pub struct EditorToolRow {
    pub name: String,
    pub version: String,
    pub status: EditorRowStatus,
    /// Original name (for rename tracking in toml_edit Document).
    pub original_name: Option<String>,
}

/// A single editable row in the editor's Env sub-tab.
#[derive(Debug, Clone)]
pub struct EditorEnvRow {
    pub key: String,
    pub value: String,
    pub status: EditorRowStatus,
    pub original_key: Option<String>,
}

/// A single editable row in the editor's Tasks sub-tab.
#[derive(Debug, Clone)]
pub struct EditorTaskRow {
    pub name: String,
    pub command: String,
    pub status: EditorRowStatus,
    pub original_name: Option<String>,
}

/// Full state for the inline editor popup.
#[derive(Debug, Clone)]
pub struct EditorState {
    /// Absolute path to the .mise.toml being edited.
    pub file_path: String,
    /// Active sub-tab (Tools / Env / Tasks).
    pub tab: EditorTab,
    /// Tool rows parsed from [tools] table.
    pub tools: Vec<EditorToolRow>,
    /// Env rows parsed from [env] table.
    pub env_vars: Vec<EditorEnvRow>,
    /// Task rows parsed from [tasks] table.
    pub tasks: Vec<EditorTaskRow>,
    /// Currently selected row index (within the active sub-tab).
    pub selected: usize,
    /// True when the user is in inline edit mode (typing into a cell).
    pub editing: bool,
    /// Which column is being edited (0 = name/key, 1 = version/value/command).
    pub edit_column: usize,
    /// Text buffer for the cell being edited.
    pub edit_buffer: String,
    /// The raw toml_edit Document for round-trip writes.
    /// Stored as String (serialized Document) to keep model.rs free of toml_edit dependency.
    /// Re-parsed in write_editor_changes().
    pub raw_document: String,
    /// True if any row has been modified/added/deleted since open.
    pub dirty: bool,
}
```

The `raw_document` stores the serialized toml_edit::DocumentMut as a String so that model.rs does not need to depend on toml_edit directly. mise.rs re-parses it during write.
  </action>
  <verify>
    <automated>cd /home/ihsen/Documents/repos/misetui && cargo check 2>&1 | tail -5</automated>
    <manual>Verify EditorState and related types exist in model.rs</manual>
  </verify>
  <done>toml_edit is in Cargo.toml dependencies. EditorState, EditorTab, EditorToolRow, EditorEnvRow, EditorTaskRow, EditorRowStatus types exist in model.rs and compile.</done>
</task>

<task type="auto">
  <name>Task 2: Add parse/write functions and editor Action/Popup wiring</name>
  <files>src/mise.rs, src/action.rs, src/app.rs, src/main.rs</files>
  <action>
1. In src/mise.rs, add two new functions:

```rust
/// Parse a .mise.toml file into EditorState using toml_edit for round-trip preservation.
/// Returns an EditorState with tools from [tools], env vars from [env], tasks from [tasks].
pub async fn parse_config_for_editor(path: &str) -> Result<EditorState, String> {
    use toml_edit::DocumentMut;
    let contents = tokio::fs::read_to_string(path).await
        .map_err(|e| format!("Failed to read {path}: {e}"))?;
    let doc: DocumentMut = contents.parse::<DocumentMut>()
        .map_err(|e| format!("Failed to parse TOML: {e}"))?;

    let mut tools = Vec::new();
    if let Some(table) = doc.get("tools").and_then(|v| v.as_table()) {
        for (key, value) in table.iter() {
            let version = match value.as_str() {
                Some(s) => s.to_string(),
                None => match value.as_array() {
                    Some(arr) => arr.iter()
                        .filter_map(|v| v.as_str())
                        .next()
                        .unwrap_or("?")
                        .to_string(),
                    None => value.to_string().trim_matches('"').to_string(),
                },
            };
            tools.push(EditorToolRow {
                name: key.to_string(),
                version,
                status: EditorRowStatus::Unchanged,
                original_name: Some(key.to_string()),
            });
        }
    }

    let mut env_vars = Vec::new();
    if let Some(table) = doc.get("env").and_then(|v| v.as_table()) {
        for (key, value) in table.iter() {
            let val_str = match value.as_str() {
                Some(s) => s.to_string(),
                None => value.to_string().trim_matches('"').to_string(),
            };
            env_vars.push(EditorEnvRow {
                key: key.to_string(),
                value: val_str,
                status: EditorRowStatus::Unchanged,
                original_key: Some(key.to_string()),
            });
        }
    }

    let mut tasks = Vec::new();
    if let Some(table) = doc.get("tasks").and_then(|v| v.as_table()) {
        for (key, value) in table.iter() {
            let command = match value.as_str() {
                Some(s) => s.to_string(),
                None => match value.as_table() {
                    Some(t) => t.get("run")
                        .and_then(|v| v.as_str())
                        .unwrap_or("")
                        .to_string(),
                    None => value.to_string().trim_matches('"').to_string(),
                },
            };
            tasks.push(EditorTaskRow {
                name: key.to_string(),
                command,
                status: EditorRowStatus::Unchanged,
                original_name: Some(key.to_string()),
            });
        }
    }

    Ok(EditorState {
        file_path: path.to_string(),
        tab: EditorTab::Tools,
        tools,
        env_vars,
        tasks,
        selected: 0,
        editing: false,
        edit_column: 0,
        edit_buffer: String::new(),
        raw_document: doc.to_string(),
        dirty: false,
    })
}

/// Write editor changes back to the .mise.toml file using toml_edit for round-trip preservation.
/// Applies all modifications (edits, adds, deletes) to the stored Document, then writes atomically.
pub async fn write_editor_changes(state: &EditorState) -> Result<String, String> {
    use toml_edit::{DocumentMut, value, Item, Table};
    let mut doc: DocumentMut = state.raw_document.parse::<DocumentMut>()
        .map_err(|e| format!("Failed to re-parse document: {e}"))?;

    // Apply tool changes
    {
        let tools_table = doc.entry("tools").or_insert(Item::Table(Table::new()));
        let table = tools_table.as_table_mut()
            .ok_or_else(|| "[tools] is not a table".to_string())?;

        // Delete removed tools (by original_name)
        for row in &state.tools {
            if row.status == EditorRowStatus::Deleted {
                if let Some(ref orig) = row.original_name {
                    table.remove(orig);
                }
            }
        }
        // Update modified and add new tools
        for row in &state.tools {
            match row.status {
                EditorRowStatus::Modified => {
                    // Remove old key if renamed
                    if let Some(ref orig) = row.original_name {
                        if orig != &row.name { table.remove(orig); }
                    }
                    table.insert(&row.name, value(&row.version));
                }
                EditorRowStatus::Added => {
                    table.insert(&row.name, value(&row.version));
                }
                _ => {}
            }
        }
    }

    // Apply env changes
    {
        let env_table = doc.entry("env").or_insert(Item::Table(Table::new()));
        let table = env_table.as_table_mut()
            .ok_or_else(|| "[env] is not a table".to_string())?;

        for row in &state.env_vars {
            if row.status == EditorRowStatus::Deleted {
                if let Some(ref orig) = row.original_key { table.remove(orig); }
            }
        }
        for row in &state.env_vars {
            match row.status {
                EditorRowStatus::Modified => {
                    if let Some(ref orig) = row.original_key {
                        if orig != &row.key { table.remove(orig); }
                    }
                    table.insert(&row.key, value(&row.value));
                }
                EditorRowStatus::Added => {
                    table.insert(&row.key, value(&row.value));
                }
                _ => {}
            }
        }
    }

    // Apply task changes
    {
        let tasks_table = doc.entry("tasks").or_insert(Item::Table(Table::new()));
        let table = tasks_table.as_table_mut()
            .ok_or_else(|| "[tasks] is not a table".to_string())?;

        for row in &state.tasks {
            if row.status == EditorRowStatus::Deleted {
                if let Some(ref orig) = row.original_name { table.remove(orig); }
            }
        }
        for row in &state.tasks {
            match row.status {
                EditorRowStatus::Modified => {
                    if let Some(ref orig) = row.original_name {
                        if orig != &row.name { table.remove(orig); }
                    }
                    table.insert(&row.name, value(&row.command));
                }
                EditorRowStatus::Added => {
                    table.insert(&row.name, value(&row.command));
                }
                _ => {}
            }
        }
    }

    // Atomic write: temp file + rename
    let path = std::path::Path::new(&state.file_path);
    let tmp_path = path.with_extension("toml.tmp");
    let content = doc.to_string();

    tokio::fs::write(&tmp_path, &content).await
        .map_err(|e| format!("Failed to write temp file: {e}"))?;
    tokio::fs::rename(&tmp_path, path).await
        .map_err(|e| format!("Failed to rename temp file: {e}"))?;

    Ok(format!("Saved {}", state.file_path))
}
```

Add the necessary imports at the top of mise.rs:
```rust
use crate::model::{EditorState, EditorTab, EditorToolRow, EditorEnvRow, EditorTaskRow, EditorRowStatus};
```

2. In src/action.rs, add these variants to the Action enum (in a new `// Inline Editor` section, after the `// Bootstrap Wizard` section):

```rust
// Inline Editor
OpenEditor { path: String },
EditorLoaded(Box<EditorState>),
EditorSwitchTab,
EditorStartEdit,
EditorConfirmEdit,
EditorCancelEdit,
EditorDeleteRow,
EditorAddTool,
EditorAddEnvVar,
EditorAddTask,
EditorWrite,
EditorWriteComplete(String),
EditorClose,
EditorInput(char),
EditorBackspace,
```

Note: EditorLoaded wraps EditorState in Box because it is a large struct; this avoids bloating the Action enum size.

Add the import for EditorState: `use crate::model::EditorState;` (it needs to be added to the existing use statement at the top of action.rs, alongside DetectedTool etc.).

3. In src/app.rs, add a `Popup::Editor(Box<EditorState>)` variant to the Popup enum. Add the `EditorState` import to the existing `use crate::model::{ ... }` at the top.

4. In src/app.rs handle_action, add these new arms inside the main `match action` block (after the WizardCompleted handling, before SaveScanConfig):

```rust
Action::OpenEditor { path } => {
    if self.popup.is_some() { return; }
    self.popup = Some(Popup::Progress {
        message: format!("Loading {}...", path),
    });
    let tx = self.action_tx.clone();
    tokio::spawn(async move {
        match mise::parse_config_for_editor(&path).await {
            Ok(state) => { let _ = tx.send(Action::EditorLoaded(Box::new(state))); }
            Err(e) => { let _ = tx.send(Action::OperationFailed(e)); }
        }
    });
}
Action::EditorLoaded(state) => {
    self.popup = Some(Popup::Editor(state));
}
// Editor actions handled by intercept block (Plan 02) — stubs to prevent non-exhaustive match
Action::EditorSwitchTab
| Action::EditorStartEdit
| Action::EditorConfirmEdit
| Action::EditorCancelEdit
| Action::EditorDeleteRow
| Action::EditorAddTool
| Action::EditorAddEnvVar
| Action::EditorAddTask
| Action::EditorWrite
| Action::EditorInput(_)
| Action::EditorBackspace
| Action::EditorClose => {}
Action::EditorWriteComplete(msg) => {
    self.popup = None;
    self.status_message = Some((msg, 20));
    self.start_fetch(); // EDIT-09: refresh config + tools
}
```

5. Add 'e' keybinding in remap_normal_action in src/main.rs — BUT the keybinding should trigger OpenEditor only on Config and Projects tabs. Since remap_normal_action doesn't have access to `app`, the 'e' key will map to a new action. The simplest approach: map 'e' to `Action::EditorStartEdit` in remap_normal_action, and in handle_action's `EditorStartEdit` arm (when no popup is open), check the current tab and dispatch OpenEditor with the selected config file path.

Actually, to keep it clean: in remap_normal_action, add `'e' => Action::EditorStartEdit`. Then in handle_action, update the EditorStartEdit arm to check for the right context:

Replace the stub `Action::EditorStartEdit` arm with:
```rust
Action::EditorStartEdit => {
    // When no popup: open editor for selected config file
    if self.popup.is_none() {
        let path = match self.tab {
            Tab::Config => {
                let configs = self.visible_configs_vec();
                configs.get(self.config_selected).map(|c| c.path.clone())
            }
            Tab::Projects => {
                if let Some(&idx) = self.filtered_projects.get(self.projects_selected) {
                    let proj = &self.projects[idx];
                    let p = std::path::Path::new(&proj.path).join(".mise.toml");
                    if p.exists() { Some(p.to_string_lossy().to_string()) } else { None }
                } else { None }
            }
            _ => None,
        };
        if let Some(path) = path {
            self.handle_action(Action::OpenEditor { path });
        }
    }
}
```

6. In popup.rs render function, add a match arm for Popup::Editor to avoid non-exhaustive match errors. For now, render a simple placeholder (Plan 03 replaces this with the full renderer):
```rust
Popup::Editor(ref _state) => {
    // Full renderer added in Plan 03 (editor.rs)
    let area = centered_rect(70, 24, f.area());
    f.render_widget(Clear, area);
    let block = Block::default()
        .title(Span::styled(" Editor ", theme::title()))
        .borders(Borders::ALL)
        .border_type(BorderType::Rounded)
        .border_style(theme::popup_border())
        .style(theme::popup_bg());
    let msg = Paragraph::new("  Loading editor...").block(block);
    f.render_widget(msg, area);
}
```

7. In src/main.rs, add `is_editor_active` helper function:
```rust
fn is_editor_active(app: &App) -> bool {
    matches!(app.popup, Some(Popup::Editor(_)))
}
```

And add a check in the event loop, before the wizard check, routing to a `remap_editor_action` stub that passes through for now (Plan 02 implements the full remap):
```rust
} else if is_editor_active(&app) {
    remap_editor_action(event_action)
```

Add stub remap:
```rust
fn remap_editor_action(action: Action) -> Action {
    match action {
        Action::CancelPopup => Action::CancelPopup,
        _ => Action::None,
    }
}
```
  </action>
  <verify>
    <automated>cd /home/ihsen/Documents/repos/misetui && cargo check 2>&1 | tail -5</automated>
    <manual>Verify 'e' key on Config tab opens a Progress popup then loads the Editor popup</manual>
  </verify>
  <done>toml_edit parses .mise.toml into EditorState. write_editor_changes() applies changes atomically. Action::OpenEditor dispatched from 'e' key on Config/Projects tabs. Popup::Editor variant exists and is rendered as placeholder. cargo check passes.</done>
</task>

</tasks>

<verification>
1. `cargo check` passes with no errors
2. EditorState, EditorTab, EditorRowStatus, EditorToolRow, EditorEnvRow, EditorTaskRow exist in model.rs
3. parse_config_for_editor() and write_editor_changes() exist in mise.rs
4. Action::OpenEditor, EditorLoaded, EditorWrite, EditorWriteComplete exist in action.rs
5. Popup::Editor variant exists in app.rs
6. 'e' key in remap_normal_action maps to EditorStartEdit
7. is_editor_active() helper exists in main.rs
</verification>

<success_criteria>
- `cargo check` passes
- Pressing 'e' on Config tab triggers OpenEditor with the selected config file path
- EditorLoaded populates a Popup::Editor with parsed tools, env vars, and tasks
- write_editor_changes() produces a valid TOML file preserving original formatting
- All EDIT-01, EDIT-07, EDIT-08 foundation code is in place
</success_criteria>

<output>
After completion, create `.planning/phases/04-inline-editor/04-01-SUMMARY.md`
</output>
