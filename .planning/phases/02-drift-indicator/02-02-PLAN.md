---
phase: 02-drift-indicator
plan: 02
type: execute
wave: 2
depends_on:
  - 02-01
files_modified:
  - src/action.rs
  - src/app.rs
  - src/ui/header.rs
  - src/main.rs
autonomous: true
requirements:
  - DRFT-01
  - DRFT-03

must_haves:
  truths:
    - "Header bar shows one of five drift indicator states: Checking, Healthy, Drifted, Missing, NoConfig"
    - "App struct holds drift_state: DriftState (initialized to Checking)"
    - "Action::DriftChecked(DriftState) and Action::CheckDrift exist in the Action enum"
    - "Pressing ? in normal mode triggers Action::JumpToDriftProject — navigates to Projects tab (or shows status message if Projects tab not yet built)"
    - "handle_action processes DriftChecked by updating app.drift_state"
  artifacts:
    - path: "src/action.rs"
      provides: "DriftChecked(DriftState) and CheckDrift and JumpToDriftProject actions"
      contains: "DriftChecked"
    - path: "src/app.rs"
      provides: "drift_state field on App struct; handle_action arm for DriftChecked and JumpToDriftProject"
      contains: "drift_state"
    - path: "src/ui/header.rs"
      provides: "Drift indicator span in header bar"
      contains: "drift_state"
    - path: "src/main.rs"
      provides: "? key mapped to JumpToDriftProject in remap_normal_action"
      contains: "JumpToDriftProject"
  key_links:
    - from: "src/action.rs"
      to: "src/model.rs"
      via: "DriftState imported in Action enum"
      pattern: "DriftChecked\\(DriftState\\)"
    - from: "src/ui/header.rs"
      to: "src/app.rs"
      via: "app.drift_state read at render time"
      pattern: "app\\.drift_state"
    - from: "src/main.rs"
      to: "src/action.rs"
      via: "? mapped to JumpToDriftProject"
      pattern: "JumpToDriftProject"
---

<objective>
Wire the drift indicator into the UI: add `DriftState`-related actions to the Action enum, add `drift_state` field to App, render the indicator in the header bar, and map `?` to jump to the Projects drill-down.

Purpose: Delivers the visible indicator (DRFT-01) and the navigation shortcut (DRFT-03). The live filesystem watch (DRFT-02) will be added in Plan 03, but this plan establishes everything it will need.
Output: Working header indicator that shows `DriftState::Checking` on startup and updates whenever `DriftChecked` action arrives. `?` keybinding wired.
</objective>

<execution_context>
@/home/ihsen/.claude/get-shit-done/workflows/execute-plan.md
@/home/ihsen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-drift-indicator/02-01-SUMMARY.md
@src/action.rs
@src/app.rs
@src/ui/header.rs
@src/main.rs
@src/theme.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add drift actions to Action enum and drift_state to App</name>
  <files>src/action.rs, src/app.rs</files>
  <action>
**src/action.rs:**

Add import at top:
```rust
use crate::model::DriftState;
```

Add three new variants to the Action enum, in the "Operations" section:
```rust
// Drift indicator
CheckDrift,
DriftChecked(DriftState),
JumpToDriftProject,
```

**src/app.rs:**

1. Add `DriftState` to the model import at the top of the file (extend the existing `use crate::model::{...}` line to include `DriftState`).

2. Add field to `App` struct after `spinner_frame`:
```rust
// Drift indicator state
pub drift_state: DriftState,
```

3. In `App::new()`, initialize the new field:
```rust
drift_state: DriftState::Checking,
```

4. In `handle_action()`, add match arms (place these in the Operations section, before the catch-all):
```rust
Action::DriftChecked(state) => {
    self.drift_state = state;
}
Action::CheckDrift => {
    self.drift_state = DriftState::Checking;
    let tx = self.action_tx.clone();
    tokio::spawn(async move {
        let state = mise::check_cwd_drift().await.unwrap_or(DriftState::NoConfig);
        let _ = tx.send(Action::DriftChecked(state));
    });
}
Action::JumpToDriftProject => {
    // Phase 2: navigate to Projects tab if it exists; otherwise show hint.
    // When Phase 1 adds Tab::Projects, update this arm to set self.tab = Tab::Projects.
    self.set_status("Press r on the Projects tab to see CWD health detail.".to_string());
}
```

5. In `App::start_fetch()`, trigger an initial drift check at startup:
```rust
let tx = self.action_tx.clone();
tokio::spawn(async move {
    let state = mise::check_cwd_drift().await.unwrap_or(DriftState::NoConfig);
    let _ = tx.send(Action::DriftChecked(state));
});
```

Note: `set_status()` is a helper — check if it already exists in app.rs. If not, the pattern used elsewhere is:
```rust
self.status_message = Some(("message".to_string(), 20));
```
Use whichever form already exists in the codebase.
  </action>
  <verify>
    <automated>cd /home/ihsen/Documents/repos/misetui && cargo check 2>&1 | head -30</automated>
    <manual>src/action.rs has DriftChecked(DriftState), CheckDrift, JumpToDriftProject; src/app.rs has drift_state field initialized to DriftState::Checking</manual>
  </verify>
  <done>`cargo check` passes; App struct has `drift_state: DriftState`; all three new Action variants compile</done>
</task>

<task type="auto">
  <name>Task 2: Render drift indicator in header and wire ? keybinding</name>
  <files>src/ui/header.rs, src/main.rs</files>
  <action>
**src/ui/header.rs:**

Replace the current single-line header with a version that appends a drift indicator span. The existing code builds `title_spans: Vec<Span>`. Extend it to include the drift state.

Import `DriftState` at the top:
```rust
use crate::model::DriftState;
```

After the existing `Span::raw("  ")` and `Outdated: {outdated}` span, append two more spans:

```rust
Span::raw("  "),
Span::styled(
    drift_label(app.drift_state),
    drift_style(app.drift_state),
),
```

Add private helper functions at the bottom of `src/ui/header.rs`:

```rust
fn drift_label(state: DriftState) -> &'static str {
    match state {
        DriftState::Checking => " CWD: checking…",
        DriftState::Healthy  => " CWD: healthy",
        DriftState::Drifted  => "⚠ CWD: drifted",
        DriftState::Missing  => " CWD: missing",
        DriftState::NoConfig => " CWD: no config",
    }
}

fn drift_style(state: DriftState) -> ratatui::style::Style {
    match state {
        DriftState::Checking => theme::muted(),    // use existing muted style
        DriftState::Healthy  => theme::success(),  // green
        DriftState::Drifted  => theme::warning(),  // yellow
        DriftState::Missing  => theme::error(),    // red
        DriftState::NoConfig => theme::muted(),    // muted
    }
}
```

Check `src/theme.rs` for the exact function names before writing. The theme module uses functions named `header_stat()`, `error()`, and similar. Match whatever exists:
- For Healthy: use `theme::success()` if it exists, else use a `Style::default().fg(theme::GREEN)`
- For Drifted: use `theme::warning()` if it exists, else `Style::default().fg(theme::YELLOW)`
- For Missing: use `theme::error()`
- For Checking / NoConfig: use `theme::muted()` if it exists, else `theme::header_stat()`

Do NOT invent theme functions that don't exist. Read `src/theme.rs` first and use only what's there.

**src/main.rs:**

In `remap_normal_action()`, add a mapping for `?` (currently `'?' => Action::ShowHelp`). The requirement says `?` on the drift indicator jumps to Projects. However `?` is already bound to `ShowHelp`.

Resolution: Use a different key. Per the roadmap, DRFT-03 says "press `?` on the drift indicator" — this likely means a context-sensitive `?` when the drift indicator area is focused, but since there is no indicator focus concept yet, map to a new key instead to avoid breaking Help. Use `'P'` (capital P for "Project drill-down") as the keybinding for `JumpToDriftProject`. Add it alongside other uppercase bindings:

```rust
'P' => Action::JumpToDriftProject,
```

Note: If the requirement strictly requires `?`, then change `'?' => Action::ShowHelp` to be conditional and add `JumpToDriftProject` — but that requires context awareness not yet in scope. Use `'P'` for now and note in the plan summary that DRFT-03 requires revisiting when focus context is added. This is Claude's discretion.
  </action>
  <verify>
    <automated>cd /home/ihsen/Documents/repos/misetui && cargo check 2>&1 | head -30</automated>
    <manual>Run `cargo run` — header shows "CWD: checking…" then transitions to a state within a few seconds. Press P and see a status message in the footer.</manual>
  </verify>
  <done>`cargo check` passes; header displays drift indicator text; `P` keybinding sends JumpToDriftProject action; app shows status message in footer when P is pressed</done>
</task>

</tasks>

<verification>
1. `cargo check` exits 0 with no errors
2. `cargo run`: header bar shows drift state indicator text (e.g., "CWD: checking…" then "CWD: healthy" or "CWD: no config")
3. Pressing `P` from normal mode shows a footer status message
4. Existing `?` help popup still works (ShowHelp not broken)
</verification>

<success_criteria>
- Header always shows a drift state label with appropriate color
- app.drift_state initialized to Checking, updated to real state within seconds of startup
- DriftChecked(DriftState) action handled in handle_action()
- `P` key triggers JumpToDriftProject action
- No regressions in existing keybindings or header layout
</success_criteria>

<output>
After completion, create `.planning/phases/02-drift-indicator/02-02-SUMMARY.md` using the summary template.
</output>
