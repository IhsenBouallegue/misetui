---
phase: 03-bootstrap-wizard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/model.rs
  - src/mise.rs
autonomous: true
requirements:
  - BOOT-01
  - BOOT-02
  - BOOT-03

must_haves:
  truths:
    - "WizardState and WizardStep types exist and compile cleanly"
    - "DetectedTool has an installed: bool field populated by cross-referencing mise ls -J output"
    - "detect_project_tools() is async: reads filesystem files then calls mise ls -J to mark already-installed tools"
    - "migrate_legacy_pins() reads .nvmrc, .python-version, .ruby-version, .tool-versions and carries over exact version strings"
  artifacts:
    - path: "src/model.rs"
      provides: "WizardState, WizardStep, DetectedTool structs"
      contains: "pub struct WizardState"
    - path: "src/mise.rs"
      provides: "detect_project_tools(), migrate_legacy_pins()"
      contains: "pub async fn detect_project_tools"
  key_links:
    - from: "src/model.rs"
      to: "src/app.rs"
      via: "WizardState imported into Popup::Wizard variant (Plan 02)"
      pattern: "WizardState"
    - from: "src/mise.rs"
      to: "src/app.rs"
      via: "detect_project_tools/migrate_legacy_pins called in handle_action (Plan 02)"
      pattern: "detect_project_tools"
---

<objective>
Implement the data model and detection/migration logic for the Bootstrap Wizard.

Purpose: Foundation that Plans 02 and 03 build on top of — all state types and pure filesystem functions defined here.
Output: `WizardState` model in model.rs, `detect_project_tools()` and `migrate_legacy_pins()` in mise.rs.
</objective>

<execution_context>
@/home/ihsen/.claude/get-shit-done/workflows/execute-plan.md
@/home/ihsen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/model.rs
@src/mise.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add WizardState model types to model.rs</name>
  <files>src/model.rs</files>
  <action>
Append the following new types to the end of src/model.rs (after the MiseProject struct):

```rust
/// A tool detected from filesystem indicators or migrated from legacy pin files.
#[derive(Debug, Clone)]
pub struct DetectedTool {
    /// Short tool name as used by mise (e.g. "node", "python", "rust", "go", "ruby", "php").
    pub name: String,
    /// Version string if migrated from a legacy pin file (e.g. "20.11.0"), or empty if auto-detected without a pin.
    pub version: String,
    /// Source description for display (e.g. "package.json", ".nvmrc", "Cargo.toml").
    pub source: String,
    /// Whether this tool is toggled ON (will be written to .mise.toml). Defaults to true.
    pub enabled: bool,
    /// True if this tool version is already installed locally (from `mise ls -J` cross-reference).
    pub installed: bool,
}

/// Multi-step wizard state for BOOT-01 through BOOT-07.
#[derive(Debug, Clone)]
pub struct WizardState {
    /// Target directory for the .mise.toml to be written.
    pub target_dir: String,
    /// Current step in the wizard flow.
    pub step: WizardStep,
    /// Tools detected/migrated — each with enabled flag for toggling in Review step.
    pub tools: Vec<DetectedTool>,
    /// Which tool row is currently highlighted in Review step.
    pub selected: usize,
    /// Generated .mise.toml content (populated when entering Preview step).
    pub preview_content: String,
    /// If true, write AGENTS.md and CLAUDE.md alongside .mise.toml (BOOT-07).
    pub write_agent_files: bool,
    /// Scroll offset for Preview step paragraph.
    pub preview_scroll: usize,
}

/// Steps in the Bootstrap Wizard flow.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum WizardStep {
    /// Scanning filesystem — spinner shown.
    Detecting,
    /// User reviews and toggles tool list.
    Review,
    /// User previews the generated .mise.toml content.
    Preview,
    /// Writing file and running mise install — spinner shown.
    Writing,
}
```

These types are pure data with no side effects — safe to derive Debug+Clone.
  </action>
  <verify>
    <automated>cd /home/ihsen/Documents/repos/misetui && cargo check 2>&1 | head -20</automated>
    <manual>Confirm WizardState, WizardStep, DetectedTool are present and compile without errors.</manual>
  </verify>
  <done>cargo check passes; model.rs contains WizardState, WizardStep, DetectedTool structs.</done>
</task>

<task type="auto">
  <name>Task 2: Add detect_project_tools() and migrate_legacy_pins() to mise.rs</name>
  <files>src/mise.rs</files>
  <action>
Add the following two public functions to src/mise.rs.

`detect_project_tools` is **async** — it does filesystem I/O then calls `mise ls -J` to cross-reference already-installed tools and populate `DetectedTool::installed`.

`migrate_legacy_pins` remains synchronous (pure fs I/O, called internally by detect_project_tools).

First, add `DetectedTool` to the existing `use crate::model::{...}` import at the top of mise.rs.

Then append both functions at the end of mise.rs:

```rust
/// Detect tools from filesystem indicators in `dir`, then cross-reference against
/// `mise ls -J` to mark which tools are already installed.
///
/// Filesystem mapping:
///   package.json        → node  (version from .nvmrc, else "lts")
///   Cargo.toml          → rust  (version "stable")
///   pyproject.toml / requirements.txt → python (version from .python-version, else "latest")
///   go.mod              → go    (version "latest")
///   Gemfile             → ruby  (version from .ruby-version, else "latest")
///   composer.json       → php   (version "latest")
///   .tool-versions      → all tools (via migrate_legacy_pins, lowest priority)
///
/// Returns Vec<DetectedTool> sorted by name; `enabled = true`, `installed` from mise ls -J.
pub async fn detect_project_tools(dir: &str) -> Vec<DetectedTool> {
    use std::collections::HashMap;
    use std::path::Path;

    let base = Path::new(dir);

    // Helper: read first non-empty, non-comment line
    let read_first_line = |p: &Path| -> Option<String> {
        std::fs::read_to_string(p).ok().and_then(|s| {
            s.lines()
                .map(|l| l.trim().to_string())
                .find(|l| !l.is_empty() && !l.starts_with('#'))
        })
    };

    let nvmrc_version   = base.join(".nvmrc").exists().then(|| read_first_line(&base.join(".nvmrc"))).flatten();
    let python_version  = base.join(".python-version").exists().then(|| read_first_line(&base.join(".python-version"))).flatten();
    let ruby_version    = base.join(".ruby-version").exists().then(|| read_first_line(&base.join(".ruby-version"))).flatten();

    let mut tools: HashMap<String, DetectedTool> = HashMap::new();

    // .tool-versions first (lowest priority)
    if base.join(".tool-versions").exists() {
        for t in migrate_legacy_pins(dir) {
            tools.insert(t.name.clone(), t);
        }
    }

    // Filesystem indicators (higher priority)
    macro_rules! insert_tool {
        ($name:expr, $version:expr, $source:expr) => {
            tools.insert($name.to_string(), DetectedTool {
                name: $name.to_string(),
                version: $version,
                source: $source.to_string(),
                enabled: true,
                installed: false, // populated below
            });
        };
    }

    if base.join("package.json").exists() {
        let (v, s) = nvmrc_version.as_deref().map(|v| (v.to_string(), ".nvmrc")).unwrap_or(("lts".to_string(), "package.json"));
        insert_tool!("node", v, s);
    }
    if base.join("Cargo.toml").exists() {
        insert_tool!("rust", "stable".to_string(), "Cargo.toml");
    }
    if base.join("pyproject.toml").exists() || base.join("requirements.txt").exists() {
        let src = if base.join("pyproject.toml").exists() { "pyproject.toml" } else { "requirements.txt" };
        let (v, s) = python_version.as_deref().map(|v| (v.to_string(), ".python-version")).unwrap_or(("latest".to_string(), src));
        insert_tool!("python", v, s);
    }
    if base.join("go.mod").exists() {
        insert_tool!("go", "latest".to_string(), "go.mod");
    }
    if base.join("Gemfile").exists() {
        let (v, s) = ruby_version.as_deref().map(|v| (v.to_string(), ".ruby-version")).unwrap_or(("latest".to_string(), "Gemfile"));
        insert_tool!("ruby", v, s);
    }
    if base.join("composer.json").exists() {
        insert_tool!("php", "latest".to_string(), "composer.json");
    }

    // Standalone legacy pin files (no matching indicator file)
    if !tools.contains_key("node") {
        if let Some(v) = &nvmrc_version { insert_tool!("node", v.clone(), ".nvmrc"); }
    }
    if !tools.contains_key("python") {
        if let Some(v) = &python_version { insert_tool!("python", v.clone(), ".python-version"); }
    }
    if !tools.contains_key("ruby") {
        if let Some(v) = &ruby_version { insert_tool!("ruby", v.clone(), ".ruby-version"); }
    }

    // Cross-reference with `mise ls -J` to mark already-installed tools.
    // JSON structure: { "tool-name": [ { "version": "x.y.z", ... }, ... ] }
    if let Ok(json) = run_mise(&["ls", "-J"]).await {
        if let Ok(map) = serde_json::from_str::<serde_json::Map<String, serde_json::Value>>(&json) {
            for (tool_name, entry) in tools.iter_mut() {
                if let Some(versions) = map.get(tool_name).and_then(|v| v.as_array()) {
                    let wanted = entry.version.as_str();
                    entry.installed = versions.iter().any(|v| {
                        let installed_ver = v["version"].as_str().unwrap_or("");
                        wanted == "latest" || wanted == "stable" || wanted == "lts"
                            || installed_ver == wanted
                            || installed_ver.starts_with(&format!("{wanted}."))
                    });
                }
            }
        }
    }

    let mut result: Vec<DetectedTool> = tools.into_values().collect();
    result.sort_by(|a, b| a.name.cmp(&b.name));
    result
}

/// Parse `.tool-versions` in `dir` and return a DetectedTool per line.
/// Format: `tool version` per line; `#` comments and blank lines ignored.
pub fn migrate_legacy_pins(dir: &str) -> Vec<DetectedTool> {
    let path = std::path::Path::new(dir).join(".tool-versions");
    let Ok(contents) = std::fs::read_to_string(&path) else { return Vec::new() };
    contents
        .lines()
        .filter(|l| !l.trim().is_empty() && !l.trim().starts_with('#'))
        .filter_map(|line| {
            let mut parts = line.split_whitespace();
            let name = parts.next()?.to_string();
            let version = parts.next().unwrap_or("latest").to_string();
            Some(DetectedTool { name, version, source: ".tool-versions".to_string(), enabled: true, installed: false })
        })
        .collect()
}
```
  </action>
  <verify>
    <automated>cd /home/ihsen/Documents/repos/misetui && cargo check 2>&1 | head -30</automated>
    <manual>Confirm detect_project_tools and migrate_legacy_pins are present in mise.rs and cargo check passes.</manual>
  </verify>
  <done>cargo check passes; mise.rs exports async detect_project_tools(dir: &str) -> Vec&lt;DetectedTool&gt; and migrate_legacy_pins(dir: &str) -> Vec&lt;DetectedTool&gt;.</done>
</task>

</tasks>

<verification>
Run `cargo check` from the repo root — zero errors, warnings about unused functions are acceptable.
Grep for `WizardState` in src/model.rs and `detect_project_tools` in src/mise.rs to confirm presence.
</verification>

<success_criteria>
- src/model.rs contains WizardState, WizardStep, DetectedTool
- src/mise.rs contains detect_project_tools() and migrate_legacy_pins()
- cargo check passes with no errors
- All BOOT-01/02/03 foundation types present
</success_criteria>

<output>
After completion, create `.planning/phases/03-bootstrap-wizard/03-01-SUMMARY.md` following the summary template.
</output>
