---
phase: 01-projects-tab
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Cargo.toml
  - src/config.rs
  - src/model.rs
autonomous: true
requirements:
  - PROJ-01
  - PROJ-02
  - PROJ-03

must_haves:
  truths:
    - "App can read ~/.config/misetui/config.toml and produce scan_dirs + max_depth with defaults when file absent"
    - "App can scan directories up to max_depth for .mise.toml files and return a list of project paths"
    - "Each discovered project has a computed health status derived from required tools vs installed tools"
  artifacts:
    - path: "src/config.rs"
      provides: "MisetuiConfig struct with load() returning defaults when file absent"
      contains: "pub struct MisetuiConfig"
    - path: "src/model.rs"
      provides: "MiseProject, ProjectToolHealth, ProjectHealthStatus types"
      contains: "pub struct MiseProject"
    - path: "Cargo.toml"
      provides: "dirs dependency for ~ path resolution"
      contains: "dirs"
  key_links:
    - from: "src/config.rs"
      to: "~/.config/misetui/config.toml"
      via: "dirs::config_dir() + fs::read_to_string"
      pattern: "dirs::config_dir"
    - from: "src/model.rs"
      to: "src/app.rs"
      via: "MiseProject used as App.projects collection type"
      pattern: "pub struct MiseProject"
---

<objective>
Build the data foundation for the Projects tab: a config reader, project scanner, and health model.

Purpose: The scanner and models must exist before App state and UI can be wired. This is the standalone foundation layer — nothing in wave 2+ can proceed without these types.

Output:
- `src/config.rs` — MisetuiConfig loader with defaults
- `src/model.rs` additions — MiseProject, ProjectToolHealth, ProjectHealthStatus
- `Cargo.toml` — `dirs` crate added
- `src/mise.rs` — `scan_projects()` async function
</objective>

<execution_context>
@/home/ihsen/.claude/get-shit-done/workflows/execute-plan.md
@/home/ihsen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/model.rs
@src/mise.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dirs crate and create MisetuiConfig loader</name>
  <files>Cargo.toml, src/config.rs</files>
  <action>
    1. In Cargo.toml, add `dirs = "5"` under [dependencies]. Also add `toml = "0.8"` for parsing the config file (serde_json is already present but toml is needed for the TOML config format).

    2. Create `src/config.rs` as a new module with:

    ```rust
    use serde::Deserialize;
    use std::path::PathBuf;

    #[derive(Debug, Clone, Deserialize)]
    pub struct MisetuiConfig {
        #[serde(default = "default_scan_dirs")]
        pub scan_dirs: Vec<PathBuf>,
        #[serde(default = "default_max_depth")]
        pub max_depth: usize,
    }

    fn default_scan_dirs() -> Vec<PathBuf> {
        let mut dirs = Vec::new();
        if let Some(home) = dirs::home_dir() {
            dirs.push(home.join("projects"));
        }
        // Also include CWD
        if let Ok(cwd) = std::env::current_dir() {
            dirs.push(cwd);
        }
        dirs
    }

    fn default_max_depth() -> usize { 3 }

    impl Default for MisetuiConfig {
        fn default() -> Self {
            Self {
                scan_dirs: default_scan_dirs(),
                max_depth: default_max_depth(),
            }
        }
    }

    impl MisetuiConfig {
        /// Load from ~/.config/misetui/config.toml; returns defaults if file absent or parse fails.
        pub fn load() -> Self {
            let config_path = dirs::config_dir()
                .map(|d| d.join("misetui").join("config.toml"));

            let Some(path) = config_path else {
                return Self::default();
            };

            let Ok(contents) = std::fs::read_to_string(&path) else {
                return Self::default();
            };

            toml::from_str(&contents).unwrap_or_default()
        }
    }
    ```

    Note: Use `dirs::home_dir()` for the default projects directory. The config file path uses `dirs::config_dir()` which resolves to `~/.config` on Linux/macOS.
  </action>
  <verify>
    <automated>cargo build 2>&1 | grep -E "^error" | head -20; echo "Exit: $?"</automated>
    <manual>Check that `cargo build` compiles without errors. Verify dirs and toml appear in Cargo.lock after build.</manual>
  </verify>
  <done>src/config.rs compiles, MisetuiConfig::load() returns defaults when no config file exists, `dirs` and `toml` crates are in Cargo.toml dependencies.</done>
</task>

<task type="auto">
  <name>Task 2: Add MiseProject health model types to model.rs</name>
  <files>src/model.rs</files>
  <action>
    Append the following new types to the END of `src/model.rs`. Do not modify existing types.

    ```rust
    /// Health status for a project or individual tool requirement.
    #[derive(Debug, Clone, PartialEq, Eq)]
    pub enum ProjectHealthStatus {
        /// All required tools are installed at the correct version.
        Healthy,
        /// At least one required tool is installed but at an older version than required.
        Outdated,
        /// At least one required tool is not installed at all.
        Missing,
        /// No .mise.toml found for this project path.
        NoConfig,
    }

    impl ProjectHealthStatus {
        pub fn label(&self) -> &'static str {
            match self {
                ProjectHealthStatus::Healthy  => "● healthy",
                ProjectHealthStatus::Outdated => "◐ outdated",
                ProjectHealthStatus::Missing  => "○ missing",
                ProjectHealthStatus::NoConfig => "  no config",
            }
        }
    }

    /// Per-tool health row inside a project drill-down.
    #[derive(Debug, Clone)]
    pub struct ProjectToolHealth {
        /// Tool name (e.g. "node", "python").
        pub tool: String,
        /// Version string as specified in .mise.toml (e.g. "20", "20.1.0", "latest").
        pub required: String,
        /// Installed version string, or empty if not installed.
        pub installed: String,
        pub status: ProjectHealthStatus,
    }

    /// A project discovered by scanning configured directories.
    #[derive(Debug, Clone)]
    pub struct MiseProject {
        /// Directory name (last path component).
        pub name: String,
        /// Absolute path to the project directory (parent of .mise.toml).
        pub path: String,
        /// Number of tools declared in .mise.toml.
        pub tool_count: usize,
        /// Aggregate health status (worst-case of all tool health statuses).
        pub health: ProjectHealthStatus,
        /// Per-tool health breakdown (populated during scan).
        pub tools: Vec<ProjectToolHealth>,
    }
    ```

    The health aggregation rule: if any tool is Missing → Missing; else if any tool is Outdated → Outdated; else Healthy. NoConfig is set only when the directory has no .mise.toml.
  </action>
  <verify>
    <automated>cargo build 2>&1 | grep -E "^error" | head -20</automated>
  </verify>
  <done>model.rs compiles with all 5 new types: ProjectHealthStatus, ProjectToolHealth, MiseProject, each with their fields and impl blocks as specified.</done>
</task>

<task type="auto">
  <name>Task 3: Implement scan_projects() in mise.rs</name>
  <files>src/mise.rs</files>
  <action>
    Add `scan_projects()` to `src/mise.rs`. This function:
    - Takes the loaded config (scan_dirs, max_depth) and the current installed tool list
    - Scans directories recursively up to max_depth for `.mise.toml` files
    - Parses each `.mise.toml` to extract the `[tools]` table
    - Cross-references against `installed_tools: &[InstalledTool]` to compute per-tool health
    - Returns `Vec<MiseProject>` sorted by name

    Add the following imports at the top of mise.rs (after existing imports):
    ```rust
    use crate::config::MisetuiConfig;
    use crate::model::{MiseProject, ProjectHealthStatus, ProjectToolHealth};
    use std::path::Path;
    ```

    Add this function at the bottom of mise.rs:

    ```rust
    /// Scan configured directories for .mise.toml files and compute project health.
    /// Cross-references against `installed_tools` (already loaded in-memory) to avoid
    /// extra mise subprocess calls.
    pub fn scan_projects(
        config: &MisetuiConfig,
        installed_tools: &[crate::model::InstalledTool],
    ) -> Vec<MiseProject> {
        // Build a fast lookup: tool name → active installed version
        let mut installed_map: std::collections::HashMap<&str, &str> =
            std::collections::HashMap::new();
        for tool in installed_tools {
            if tool.active {
                installed_map.insert(tool.name.as_str(), tool.version.as_str());
            }
        }

        let mut projects = Vec::new();

        for scan_root in &config.scan_dirs {
            collect_projects(scan_root, 0, config.max_depth, &installed_map, &mut projects);
        }

        // Deduplicate by path (a dir might appear in multiple scan roots)
        projects.sort_by(|a, b| a.path.cmp(&b.path));
        projects.dedup_by(|a, b| a.path == b.path);
        projects.sort_by(|a, b| a.name.cmp(&b.name));
        projects
    }

    fn collect_projects(
        dir: &std::path::Path,
        depth: usize,
        max_depth: usize,
        installed_map: &std::collections::HashMap<&str, &str>,
        projects: &mut Vec<MiseProject>,
    ) {
        let config_path = dir.join(".mise.toml");
        if config_path.exists() {
            let project = parse_project(dir, &config_path, installed_map);
            projects.push(project);
            // Don't recurse into projects that already have a .mise.toml
            return;
        }

        if depth >= max_depth {
            return;
        }

        let Ok(entries) = std::fs::read_dir(dir) else {
            return;
        };

        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_dir() {
                // Skip hidden directories and common non-project dirs
                let name = entry.file_name();
                let name_str = name.to_string_lossy();
                if name_str.starts_with('.') || name_str == "node_modules" || name_str == "target" {
                    continue;
                }
                collect_projects(&path, depth + 1, max_depth, installed_map, projects);
            }
        }
    }

    fn parse_project(
        dir: &std::path::Path,
        config_path: &std::path::Path,
        installed_map: &std::collections::HashMap<&str, &str>,
    ) -> MiseProject {
        let name = dir
            .file_name()
            .map(|n| n.to_string_lossy().to_string())
            .unwrap_or_else(|| dir.to_string_lossy().to_string());
        let path = dir.to_string_lossy().to_string();

        let Ok(contents) = std::fs::read_to_string(config_path) else {
            return MiseProject {
                name,
                path,
                tool_count: 0,
                health: ProjectHealthStatus::NoConfig,
                tools: Vec::new(),
            };
        };

        // Parse [tools] table from .mise.toml using basic TOML parsing
        let toml_val: toml::Value = match toml::from_str(&contents) {
            Ok(v) => v,
            Err(_) => {
                return MiseProject {
                    name,
                    path,
                    tool_count: 0,
                    health: ProjectHealthStatus::NoConfig,
                    tools: Vec::new(),
                };
            }
        };

        let tool_entries: Vec<(String, String)> = toml_val
            .get("tools")
            .and_then(|t| t.as_table())
            .map(|table| {
                table
                    .iter()
                    .map(|(k, v)| {
                        let version = match v {
                            toml::Value::String(s) => s.clone(),
                            toml::Value::Array(arr) => arr
                                .first()
                                .and_then(|x| x.as_str())
                                .unwrap_or("?")
                                .to_string(),
                            other => other.to_string(),
                        };
                        (k.clone(), version)
                    })
                    .collect()
            })
            .unwrap_or_default();

        let mut tool_healths: Vec<ProjectToolHealth> = Vec::new();
        let mut worst = ProjectHealthStatus::Healthy;

        for (tool_name, required) in &tool_entries {
            let status = match installed_map.get(tool_name.as_str()) {
                None => ProjectHealthStatus::Missing,
                Some(installed_ver) => {
                    // Simple version match: if required is "latest" or matches installed, healthy.
                    // Otherwise mark outdated.
                    if required == "latest" || *installed_ver == required.as_str() {
                        ProjectHealthStatus::Healthy
                    } else {
                        ProjectHealthStatus::Outdated
                    }
                }
            };

            // Update worst-case aggregate
            match (&worst, &status) {
                (_, ProjectHealthStatus::Missing)  => worst = ProjectHealthStatus::Missing,
                (ProjectHealthStatus::Healthy, ProjectHealthStatus::Outdated) => worst = ProjectHealthStatus::Outdated,
                _ => {}
            }

            let installed = installed_map
                .get(tool_name.as_str())
                .map(|s| s.to_string())
                .unwrap_or_default();

            tool_healths.push(ProjectToolHealth {
                tool: tool_name.clone(),
                required: required.clone(),
                installed,
                status,
            });
        }

        MiseProject {
            name,
            path,
            tool_count: tool_entries.len(),
            health: worst,
            tools: tool_healths,
        }
    }
    ```

    Note: `scan_projects` is a synchronous function (filesystem I/O only, no async). It will be called inside a `tokio::spawn(async move { ... })` in app.rs in plan 02. This avoids holding async resources while walking directories.
  </action>
  <verify>
    <automated>cargo build 2>&1 | grep -E "^error" | head -20</automated>
    <manual>Check that cargo build succeeds. The function is not yet called from anywhere so dead_code warnings are expected.</manual>
  </verify>
  <done>cargo build succeeds. scan_projects(), collect_projects(), and parse_project() are defined in mise.rs and compile without errors. MiseProject types are fully wired from model.rs.</done>
</task>

</tasks>

<verification>
Run `cargo build` — must exit 0 with no errors (warnings about unused code are acceptable at this stage since the types are not yet wired into App).

Key correctness checks:
- `MisetuiConfig::load()` returns non-empty scan_dirs when no config file exists (defaults to ~/projects + CWD)
- `scan_projects()` returns empty Vec when scan_dirs are empty or contain no .mise.toml files
- Health aggregation: Missing beats Outdated beats Healthy
</verification>

<success_criteria>
- `cargo build` exits 0
- `src/config.rs` exists with `MisetuiConfig` struct and `load()` method
- `src/model.rs` contains `MiseProject`, `ProjectToolHealth`, `ProjectHealthStatus`
- `src/mise.rs` contains `scan_projects()` function
- `Cargo.toml` lists `dirs` and `toml` as dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/01-projects-tab/01-01-SUMMARY.md` following the summary template.
</output>
