---
phase: 02-drift-indicator
plan: 03
type: execute
wave: 3
depends_on:
  - 02-02
files_modified:
  - src/main.rs
autonomous: true
requirements:
  - DRFT-02

must_haves:
  truths:
    - "When .mise.toml in the CWD is saved, the drift indicator updates within ~200ms — no r keypress required"
    - "When ~/.config/mise/config.toml changes, the drift indicator also updates automatically"
    - "The watcher task shuts down cleanly when the app exits (no orphan threads)"
    - "Watcher errors do not crash the app — they are silently ignored"
  artifacts:
    - path: "src/main.rs"
      provides: "Filesystem watcher task spawned at startup, watching CWD/.mise.toml and ~/.config/mise/config.toml"
      contains: "notify"
  key_links:
    - from: "src/main.rs (watcher task)"
      to: "action_tx"
      via: "sends Action::CheckDrift on file change event"
      pattern: "Action::CheckDrift"
---

<objective>
Spawn a persistent filesystem watcher at application startup that watches `.mise.toml` in the CWD and `~/.config/mise/config.toml`. When either file changes, the watcher sends `Action::CheckDrift` through the existing action channel, triggering an automatic re-evaluation of drift state within ~200ms.

Purpose: Delivers DRFT-02 — the "live, no-r-required" update requirement. The indicator already exists (from Plan 02); this plan makes it reactive.
Output: `notify::recommended_watcher` spawned in `main.rs`, debounced to ~200ms, sending `Action::CheckDrift` on relevant file events.
</objective>

<execution_context>
@/home/ihsen/.claude/get-shit-done/workflows/execute-plan.md
@/home/ihsen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-drift-indicator/02-01-SUMMARY.md
@.planning/phases/02-drift-indicator/02-02-SUMMARY.md
@src/main.rs
@Cargo.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Spawn notify filesystem watcher in main.rs</name>
  <files>src/main.rs</files>
  <action>
Spawn the watcher **before** the main event loop in `main()`, immediately after `app.start_fetch()`.

**Imports to add at the top of src/main.rs:**
```rust
use notify::{Config as NotifyConfig, EventKind, RecommendedWatcher, RecursiveMode, Watcher};
use std::path::PathBuf;
use std::sync::mpsc as std_mpsc;
use std::time::Duration;
```

**Watcher setup (insert after `app.start_fetch();`):**

```rust
// Filesystem watcher for drift indicator (DRFT-02)
// Uses a std::sync::mpsc channel bridged to tokio via tokio::task::spawn_blocking.
let watch_tx = action_tx.clone();
tokio::spawn(async move {
    // Build list of paths to watch
    let cwd = std::env::current_dir().unwrap_or_else(|_| PathBuf::from("."));
    let mise_toml = cwd.join(".mise.toml");

    let global_config = dirs::config_dir()
        .map(|p| p.join("mise").join("config.toml"));

    // std channel — notify requires a std Sender
    let (std_tx, std_rx) = std_mpsc::channel();

    let mut watcher = match RecommendedWatcher::new(
        move |res: notify::Result<notify::Event>| {
            if let Ok(event) = res {
                // Only react to content-changing events
                match event.kind {
                    EventKind::Create(_) | EventKind::Modify(_) | EventKind::Remove(_) => {
                        let _ = std_tx.send(());
                    }
                    _ => {}
                }
            }
        },
        NotifyConfig::default().with_poll_interval(Duration::from_millis(200)),
    ) {
        Ok(w) => w,
        Err(_) => return, // Watcher unavailable — graceful degradation
    };

    // Watch .mise.toml (non-recursive; file may not exist yet)
    let _ = watcher.watch(&mise_toml, RecursiveMode::NonRecursive);
    if let Some(ref gc) = global_config {
        let _ = watcher.watch(gc, RecursiveMode::NonRecursive);
    }

    // Debounce: collect events and coalesce into a single CheckDrift every ~200ms
    loop {
        // Block waiting for an event (in a blocking context bridged to tokio)
        let received = tokio::task::spawn_blocking({
            let std_rx = unsafe {
                // SAFETY: we move std_rx into the closure; this is the only receiver
                &std_rx as *const std_mpsc::Receiver<()> as usize
            };
            move || {
                let rx = unsafe { &*(std_rx as *const std_mpsc::Receiver<()>) };
                rx.recv_timeout(Duration::from_millis(500))
            }
        }).await;

        match received {
            Ok(Ok(())) => {
                // Drain any additional events accumulated during debounce window
                tokio::time::sleep(Duration::from_millis(200)).await;
                while std_rx.try_recv().is_ok() {}
                let _ = watch_tx.send(Action::CheckDrift);
            }
            Ok(Err(_)) => {
                // recv_timeout timed out — just loop (keep watching)
            }
            Err(_) => break, // spawn_blocking panicked — exit watcher
        }
    }
});
```

**Important:** The `unsafe` pointer trick above is fragile. Use a cleaner approach instead:

Replace the entire body with a cleaner `tokio::sync::watch` or simply move `std_rx` into the `spawn_blocking` closure using an `Arc<Mutex<...>>` or by restructuring. The cleanest pattern for notify + tokio is:

```rust
use std::sync::{Arc, Mutex};

let (std_tx, std_rx) = std_mpsc::channel::<()>();
let std_rx = Arc::new(Mutex::new(std_rx));

// In the debounce loop:
let std_rx_clone = Arc::clone(&std_rx);
let received = tokio::task::spawn_blocking(move || {
    let rx = std_rx_clone.lock().unwrap();
    rx.recv_timeout(Duration::from_millis(500))
}).await;
```

Use this Arc<Mutex<Receiver>> pattern — it is safe and idiomatic for bridging std channels into tokio::task::spawn_blocking.

**dirs crate:** The `dirs::config_dir()` call requires adding `dirs = "5"` to `Cargo.toml`. Add it:
```toml
dirs = "5"
```

If `dirs` is already added (it was listed as a required crate in STATE.md decisions), confirm it is present. If not, add it now.

**Graceful degradation:** All watch errors (file not found, permission denied) are silently swallowed — the watcher just won't watch that path. The existing manual `r` refresh still works as fallback.

**No changes to event loop:** The watcher task sends `Action::CheckDrift` through the existing `action_tx` — this is already handled in `handle_action()` from Plan 02. No modifications to the select! loop or handle_action are needed.
  </action>
  <verify>
    <automated>cd /home/ihsen/Documents/repos/misetui && cargo check 2>&1 | head -30</automated>
    <manual>Run `cargo run`, edit/touch .mise.toml in the current directory with `touch .mise.toml`, and observe the header drift indicator briefly show "CWD: checking…" then update to the correct state within ~1 second — without pressing r.</manual>
  </verify>
  <done>`cargo check` passes; watcher spawns at startup; touching .mise.toml causes drift state to refresh automatically within ~400ms (200ms debounce + async check latency)</done>
</task>

</tasks>

<verification>
1. `cargo check` exits 0
2. `cargo run` — `touch .mise.toml` in CWD causes header indicator to flicker to "checking…" and resolve without any key press
3. App exits cleanly (Ctrl-C) — no thread panics or "channel closed" errors in stderr
4. If .mise.toml does not exist, the watcher handles the missing-file case gracefully (no crash)
</verification>

<success_criteria>
- File system events on `.mise.toml` trigger `Action::CheckDrift` and drift state updates automatically
- Debounce prevents rapid repeated re-checks (coalesces burst writes into one check)
- No regressions: existing manual `r` refresh still works; all other features unaffected
- `cargo check` clean
</success_criteria>

<output>
After completion, create `.planning/phases/02-drift-indicator/02-03-SUMMARY.md` using the summary template.
</output>
