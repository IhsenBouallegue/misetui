---
phase: 03-bootstrap-wizard
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/model.rs
  - src/mise.rs
autonomous: true
requirements:
  - BOOT-01
  - BOOT-02
  - BOOT-03

must_haves:
  truths:
    - "WizardState and WizardStep types exist and compile cleanly"
    - "detect_project_tools() reads filesystem files and returns a list of DetectedTool entries"
    - "migrate_legacy_pins() reads .nvmrc, .python-version, .ruby-version, .tool-versions and carries over exact version strings"
    - "Both functions are synchronous (fs I/O only), callable from tokio::spawn"
  artifacts:
    - path: "src/model.rs"
      provides: "WizardState, WizardStep, DetectedTool structs"
      contains: "pub struct WizardState"
    - path: "src/mise.rs"
      provides: "detect_project_tools(), migrate_legacy_pins()"
      contains: "pub fn detect_project_tools"
  key_links:
    - from: "src/model.rs"
      to: "src/app.rs"
      via: "WizardState imported into Popup::Wizard variant (Plan 02)"
      pattern: "WizardState"
    - from: "src/mise.rs"
      to: "src/app.rs"
      via: "detect_project_tools/migrate_legacy_pins called in handle_action (Plan 02)"
      pattern: "detect_project_tools"
---

<objective>
Implement the data model and detection/migration logic for the Bootstrap Wizard.

Purpose: Foundation that Plans 02 and 03 build on top of — all state types and pure filesystem functions defined here.
Output: `WizardState` model in model.rs, `detect_project_tools()` and `migrate_legacy_pins()` in mise.rs.
</objective>

<execution_context>
@/home/ihsen/.claude/get-shit-done/workflows/execute-plan.md
@/home/ihsen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/model.rs
@src/mise.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add WizardState model types to model.rs</name>
  <files>src/model.rs</files>
  <action>
Append the following new types to the end of src/model.rs (after the MiseProject struct):

```rust
/// A tool detected from filesystem indicators or migrated from legacy pin files.
#[derive(Debug, Clone)]
pub struct DetectedTool {
    /// Short tool name as used by mise (e.g. "node", "python", "rust", "go", "ruby", "php").
    pub name: String,
    /// Version string if migrated from a legacy pin file (e.g. "20.11.0"), or empty if auto-detected without a pin.
    pub version: String,
    /// Source description for display (e.g. "package.json", ".nvmrc", "Cargo.toml").
    pub source: String,
    /// Whether this tool is toggled ON (will be written to .mise.toml). Defaults to true.
    pub enabled: bool,
}

/// Multi-step wizard state for BOOT-01 through BOOT-07.
#[derive(Debug, Clone)]
pub struct WizardState {
    /// Target directory for the .mise.toml to be written.
    pub target_dir: String,
    /// Current step in the wizard flow.
    pub step: WizardStep,
    /// Tools detected/migrated — each with enabled flag for toggling in Review step.
    pub tools: Vec<DetectedTool>,
    /// Which tool row is currently highlighted in Review step.
    pub selected: usize,
    /// Generated .mise.toml content (populated when entering Preview step).
    pub preview_content: String,
    /// If true, write AGENTS.md and CLAUDE.md alongside .mise.toml (BOOT-07).
    pub write_agent_files: bool,
    /// Scroll offset for Preview step paragraph.
    pub preview_scroll: usize,
}

/// Steps in the Bootstrap Wizard flow.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum WizardStep {
    /// Scanning filesystem — spinner shown.
    Detecting,
    /// User reviews and toggles tool list.
    Review,
    /// User previews the generated .mise.toml content.
    Preview,
    /// Writing file and running mise install — spinner shown.
    Writing,
}
```

These types are pure data with no side effects — safe to derive Debug+Clone.
  </action>
  <verify>
    <automated>cd /home/ihsen/Documents/repos/misetui && cargo check 2>&1 | head -20</automated>
    <manual>Confirm WizardState, WizardStep, DetectedTool are present and compile without errors.</manual>
  </verify>
  <done>cargo check passes; model.rs contains WizardState, WizardStep, DetectedTool structs.</done>
</task>

<task type="auto">
  <name>Task 2: Add detect_project_tools() and migrate_legacy_pins() to mise.rs</name>
  <files>src/mise.rs</files>
  <action>
Add the following two synchronous (non-async) public functions to src/mise.rs. They are pure filesystem I/O — no mise CLI calls. They are called from tokio::spawn in handle_action (Plan 02).

First, add `use crate::model::DetectedTool;` to the existing imports at the top of mise.rs (already has `use crate::model::{...}`  — add DetectedTool to the existing list).

Then append both functions at the end of mise.rs:

```rust
/// Detect tools from filesystem indicators in `dir`.
/// Checks for the presence of these files and maps to mise tool names:
///   package.json        → node (version from .nvmrc or legacy, else "lts")
///   Cargo.toml          → rust (version "stable")
///   pyproject.toml or requirements.txt → python (version from .python-version or "latest")
///   go.mod              → go (version "latest")
///   Gemfile             → ruby (version from .ruby-version or "latest")
///   composer.json       → php (version "latest")
///   .tool-versions      → all tools listed in that file (via migrate_legacy_pins)
///
/// Legacy pin files (.nvmrc, .python-version, .ruby-version) are always checked
/// and their versions applied to matching detected tools.
///
/// Returns a Vec<DetectedTool> with `enabled = true` for all entries.
/// Deduplicates: if .tool-versions also lists node, the .nvmrc version wins for node.
pub fn detect_project_tools(dir: &str) -> Vec<DetectedTool> {
    use std::collections::HashMap;
    use std::path::Path;

    let base = Path::new(dir);
    // Ordered map: tool name → DetectedTool (last write wins for same tool)
    let mut tools: HashMap<String, DetectedTool> = HashMap::new();

    // Helper: read first non-empty line from file
    let read_first_line = |p: &Path| -> Option<String> {
        std::fs::read_to_string(p).ok().and_then(|s| {
            s.lines()
                .map(|l| l.trim().to_string())
                .find(|l| !l.is_empty() && !l.starts_with('#'))
        })
    };

    // Legacy pin files
    let nvmrc_version = base.join(".nvmrc").exists()
        .then(|| read_first_line(&base.join(".nvmrc")))
        .flatten();
    let python_version = base.join(".python-version").exists()
        .then(|| read_first_line(&base.join(".python-version")))
        .flatten();
    let ruby_version = base.join(".ruby-version").exists()
        .then(|| read_first_line(&base.join(".ruby-version")))
        .flatten();

    // .tool-versions first (lowest priority — explicit indicator files override)
    if base.join(".tool-versions").exists() {
        let migrated = migrate_legacy_pins(dir);
        for t in migrated {
            tools.insert(t.name.clone(), t);
        }
    }

    // Filesystem indicator files (higher priority — override .tool-versions entries)
    if base.join("package.json").exists() {
        let version = nvmrc_version.clone().unwrap_or_else(|| "lts".to_string());
        let source = if nvmrc_version.is_some() { ".nvmrc" } else { "package.json" };
        tools.insert("node".to_string(), DetectedTool {
            name: "node".to_string(),
            version,
            source: source.to_string(),
            enabled: true,
        });
    }
    if base.join("Cargo.toml").exists() {
        tools.insert("rust".to_string(), DetectedTool {
            name: "rust".to_string(),
            version: "stable".to_string(),
            source: "Cargo.toml".to_string(),
            enabled: true,
        });
    }
    if base.join("pyproject.toml").exists() || base.join("requirements.txt").exists() {
        let version = python_version.clone().unwrap_or_else(|| "latest".to_string());
        let source = if python_version.is_some() { ".python-version" } else if base.join("pyproject.toml").exists() { "pyproject.toml" } else { "requirements.txt" };
        tools.insert("python".to_string(), DetectedTool {
            name: "python".to_string(),
            version,
            source: source.to_string(),
            enabled: true,
        });
    }
    if base.join("go.mod").exists() {
        tools.insert("go".to_string(), DetectedTool {
            name: "go".to_string(),
            version: "latest".to_string(),
            source: "go.mod".to_string(),
            enabled: true,
        });
    }
    if base.join("Gemfile").exists() {
        let version = ruby_version.clone().unwrap_or_else(|| "latest".to_string());
        let source = if ruby_version.is_some() { ".ruby-version" } else { "Gemfile" };
        tools.insert("ruby".to_string(), DetectedTool {
            name: "ruby".to_string(),
            version,
            source: source.to_string(),
            enabled: true,
        });
    }
    if base.join("composer.json").exists() {
        tools.insert("php".to_string(), DetectedTool {
            name: "php".to_string(),
            version: "latest".to_string(),
            source: "composer.json".to_string(),
            enabled: true,
        });
    }

    // Standalone legacy pin files without a corresponding indicator file
    // (e.g. only .nvmrc present, no package.json)
    if !tools.contains_key("node") {
        if let Some(v) = &nvmrc_version {
            tools.insert("node".to_string(), DetectedTool {
                name: "node".to_string(),
                version: v.clone(),
                source: ".nvmrc".to_string(),
                enabled: true,
            });
        }
    }
    if !tools.contains_key("python") {
        if let Some(v) = &python_version {
            tools.insert("python".to_string(), DetectedTool {
                name: "python".to_string(),
                version: v.clone(),
                source: ".python-version".to_string(),
                enabled: true,
            });
        }
    }
    if !tools.contains_key("ruby") {
        if let Some(v) = &ruby_version {
            tools.insert("ruby".to_string(), DetectedTool {
                name: "ruby".to_string(),
                version: v.clone(),
                source: ".ruby-version".to_string(),
                enabled: true,
            });
        }
    }

    // Sort by name for deterministic ordering
    let mut result: Vec<DetectedTool> = tools.into_values().collect();
    result.sort_by(|a, b| a.name.cmp(&b.name));
    result
}

/// Parse `.tool-versions` in `dir` and return a DetectedTool per line.
/// Format: `tool version` (one per line; `#` comments ignored; blank lines ignored).
/// Returns empty vec if file absent or unreadable.
pub fn migrate_legacy_pins(dir: &str) -> Vec<DetectedTool> {
    let path = std::path::Path::new(dir).join(".tool-versions");
    let Ok(contents) = std::fs::read_to_string(&path) else {
        return Vec::new();
    };
    contents
        .lines()
        .filter(|l| !l.trim().is_empty() && !l.trim().starts_with('#'))
        .filter_map(|line| {
            let mut parts = line.split_whitespace();
            let name = parts.next()?.to_string();
            let version = parts.next().unwrap_or("latest").to_string();
            Some(DetectedTool {
                name: name.clone(),
                version,
                source: ".tool-versions".to_string(),
                enabled: true,
            })
        })
        .collect()
}
```
  </action>
  <verify>
    <automated>cd /home/ihsen/Documents/repos/misetui && cargo check 2>&1 | head -30</automated>
    <manual>Confirm detect_project_tools and migrate_legacy_pins are present in mise.rs and cargo check passes.</manual>
  </verify>
  <done>cargo check passes; mise.rs exports detect_project_tools(dir: &str) -> Vec&lt;DetectedTool&gt; and migrate_legacy_pins(dir: &str) -> Vec&lt;DetectedTool&gt;.</done>
</task>

</tasks>

<verification>
Run `cargo check` from the repo root — zero errors, warnings about unused functions are acceptable.
Grep for `WizardState` in src/model.rs and `detect_project_tools` in src/mise.rs to confirm presence.
</verification>

<success_criteria>
- src/model.rs contains WizardState, WizardStep, DetectedTool
- src/mise.rs contains detect_project_tools() and migrate_legacy_pins()
- cargo check passes with no errors
- All BOOT-01/02/03 foundation types present
</success_criteria>

<output>
After completion, create `.planning/phases/03-bootstrap-wizard/03-01-SUMMARY.md` following the summary template.
</output>
