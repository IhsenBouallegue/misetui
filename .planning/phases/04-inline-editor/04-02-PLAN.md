---
phase: 04-inline-editor
plan: 02
type: execute
wave: 2
depends_on:
  - "04-01"
files_modified:
  - src/main.rs
  - src/app.rs
autonomous: true
requirements:
  - EDIT-02
  - EDIT-03
  - EDIT-04
  - EDIT-05
  - EDIT-06
  - EDIT-09

must_haves:
  truths:
    - "User can switch between Tools/Env/Tasks sub-tabs with h/l or Tab inside the editor popup"
    - "User can add a tool with 'a' which opens the registry fuzzy search then version picker, appending the result to the tools list"
    - "User can edit a tool version with 'e' on a tool row, opening the version picker pre-filtered"
    - "User can delete a tool with 'd' on a tool row, showing a confirmation, then marking it Deleted"
    - "User can add and edit env vars (key/value) with 'A'/'e'"
    - "User can add and edit tasks (name/command) with 'T'/'e'"
    - "User can write changes with 'w' which calls write_editor_changes then refreshes app state"
    - "Pressing Esc with unsaved changes shows 'Unsaved changes. Discard?' dialog"
    - "After write, app refreshes config and tools automatically (EDIT-09)"
  artifacts:
    - path: "src/main.rs"
      provides: "remap_editor_action() routing all editor keybindings"
      contains: "remap_editor_action"
    - path: "src/app.rs"
      provides: "Editor intercept block handling all editor-mode actions"
      contains: "Popup::Editor"
  key_links:
    - from: "src/main.rs"
      to: "src/app.rs"
      via: "remap_editor_action maps keys to Action variants, handle_action processes them"
      pattern: "remap_editor_action"
    - from: "src/app.rs"
      to: "src/mise.rs"
      via: "EditorWrite spawns write_editor_changes async"
      pattern: "write_editor_changes"
    - from: "src/app.rs"
      to: "src/app.rs"
      via: "EditorAddTool opens VersionPicker popup (reuses existing flow)"
      pattern: "VersionPicker"
---

<objective>
Implement all editor behavior: key remapping, editor intercept block in handle_action, sub-tab switching, inline editing, add/edit/delete operations for tools/env/tasks, version picker integration, write-to-disk flow, and unsaved-changes guard.

Purpose: After this plan, the editor popup is fully interactive — users can navigate sub-tabs, modify rows, add new entries, delete entries, and write changes. The only missing piece is the visual renderer (Plan 03).

Output: Complete editor action handling in app.rs and key routing in main.rs.
</objective>

<execution_context>
@/home/ihsen/.claude/get-shit-done/workflows/execute-plan.md
@/home/ihsen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-inline-editor/04-CONTEXT.md
@.planning/phases/04-inline-editor/04-01-SUMMARY.md

@src/main.rs
@src/app.rs
@src/action.rs
@src/model.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement remap_editor_action and editor intercept block</name>
  <files>src/main.rs, src/app.rs</files>
  <action>
1. In src/main.rs, replace the stub `remap_editor_action` with the full implementation. The editor has two modes: normal navigation and inline editing. The remap function routes based on the editor's `editing` state.

Key mapping in editor NORMAL mode (not editing a cell):
- `h` or Shift+Tab → EditorSwitchTab (cycles backward through Tools/Env/Tasks)
- `l` or Tab → EditorSwitchTab (cycles forward; since we don't distinguish direction easily, use Tab/l for forward. Simplest: Tab key maps to NextTab action which remap converts to EditorSwitchTab)
- `j` / Down → MoveDown
- `k` / Up → MoveUp
- `e` → EditorStartEdit (opens inline edit on selected row's value column)
- `a` → EditorAddTool (only meaningful on Tools sub-tab; on Env/Tasks, remapped to EditorAddEnvVar/EditorAddTask respectively — but since remap doesn't know the sub-tab, send EditorAddTool and let handle_action dispatch based on active sub-tab)
- `A` → EditorAddEnvVar
- `T` → EditorAddTask
- `d` → EditorDeleteRow (with confirmation)
- `w` → EditorWrite
- `Esc` → EditorClose (which checks dirty state)
- `q` → EditorClose

Key mapping in editor EDIT mode (typing in a cell):
- printable chars → EditorInput(c)
- Backspace → EditorBackspace
- Enter → EditorConfirmEdit
- Esc → EditorCancelEdit

Since remap_editor_action does NOT have access to the app (it only takes Action), we need a way to distinguish edit mode. The simplest approach: always send the remapped action, and the intercept block in handle_action checks `editing` state to decide what to do. So the remap routes chars to EditorInput in a general way, and the intercept block ignores EditorInput when not in editing mode.

Better approach: Check `is_editor_editing` from main.rs. Add a helper:
```rust
fn is_editor_editing(app: &App) -> bool {
    if let Some(Popup::Editor(ref state)) = app.popup {
        state.editing
    } else {
        false
    }
}
```

Then in the event loop, split:
```rust
} else if is_editor_active(&app) {
    if is_editor_editing(&app) {
        remap_editor_edit_action(event_action)
    } else {
        remap_editor_action(event_action)
    }
}
```

Implement both remap functions:

```rust
/// Editor popup — normal navigation mode
fn remap_editor_action(action: Action) -> Action {
    match action {
        Action::SearchInput(c) => match c {
            'j' => Action::MoveDown,
            'k' => Action::MoveUp,
            'h' => Action::EditorSwitchTab,   // backward
            'l' => Action::EditorSwitchTab,   // forward (same action, intercept cycles)
            'e' => Action::EditorStartEdit,
            'a' => Action::EditorAddTool,      // context-dependent in handle_action
            'A' => Action::EditorAddEnvVar,
            'T' => Action::EditorAddTask,
            'd' => Action::EditorDeleteRow,
            'w' => Action::EditorWrite,
            'q' => Action::EditorClose,
            _ => Action::None,
        },
        Action::NextTab => Action::EditorSwitchTab,
        Action::PrevTab => Action::EditorSwitchTab,
        Action::Confirm => Action::EditorStartEdit,  // Enter starts editing
        Action::CancelPopup => Action::EditorClose,
        Action::MoveUp | Action::MoveDown | Action::PageUp | Action::PageDown => action,
        _ => Action::None,
    }
}

/// Editor popup — inline edit mode (typing in a cell)
fn remap_editor_edit_action(action: Action) -> Action {
    match action {
        Action::SearchInput(c) => Action::EditorInput(c),
        Action::SearchBackspace => Action::EditorBackspace,
        Action::Confirm => Action::EditorConfirmEdit,
        Action::CancelPopup => Action::EditorCancelEdit,
        _ => Action::None,
    }
}
```

2. In src/app.rs, add an editor intercept block BEFORE the ScanConfig intercept block (at the very top of handle_action, since editor is a popup that should capture all actions). The intercept follows the same pattern as ScanConfig/Wizard intercepts:

```rust
// Editor popup intercept — handles all editor-mode actions
if let Some(Popup::Editor(ref mut state)) = &mut self.popup {
    match &action {
        Action::MoveUp => {
            if !state.editing {
                let len = match state.tab {
                    EditorTab::Tools => state.tools.len(),
                    EditorTab::Env => state.env_vars.len(),
                    EditorTab::Tasks => state.tasks.len(),
                };
                if state.selected > 0 { state.selected -= 1; }
            }
            return;
        }
        Action::MoveDown => {
            if !state.editing {
                let len = match state.tab {
                    EditorTab::Tools => state.tools.len(),
                    EditorTab::Env => state.env_vars.len(),
                    EditorTab::Tasks => state.tasks.len(),
                };
                if len > 0 && state.selected + 1 < len { state.selected += 1; }
            }
            return;
        }
        Action::PageUp => {
            if !state.editing {
                state.selected = state.selected.saturating_sub(10);
            }
            return;
        }
        Action::PageDown => {
            if !state.editing {
                let len = match state.tab {
                    EditorTab::Tools => state.tools.len(),
                    EditorTab::Env => state.env_vars.len(),
                    EditorTab::Tasks => state.tasks.len(),
                };
                if len > 0 { state.selected = (state.selected + 10).min(len - 1); }
            }
            return;
        }
        Action::EditorSwitchTab => {
            if !state.editing {
                state.tab = match state.tab {
                    EditorTab::Tools => EditorTab::Env,
                    EditorTab::Env => EditorTab::Tasks,
                    EditorTab::Tasks => EditorTab::Tools,
                };
                state.selected = 0;
            }
            return;
        }
        Action::EditorStartEdit => {
            if !state.editing {
                // Start inline editing on the version/value/command column (column 1)
                let has_row = match state.tab {
                    EditorTab::Tools => state.tools.get(state.selected).is_some(),
                    EditorTab::Env => state.env_vars.get(state.selected).is_some(),
                    EditorTab::Tasks => state.tasks.get(state.selected).is_some(),
                };
                if has_row {
                    state.editing = true;
                    state.edit_column = 1; // version/value/command
                    state.edit_buffer = match state.tab {
                        EditorTab::Tools => state.tools[state.selected].version.clone(),
                        EditorTab::Env => state.env_vars[state.selected].value.clone(),
                        EditorTab::Tasks => state.tasks[state.selected].command.clone(),
                    };
                }
            }
            return;
        }
        Action::EditorConfirmEdit => {
            if state.editing {
                let buf = state.edit_buffer.clone();
                match state.tab {
                    EditorTab::Tools => {
                        if let Some(row) = state.tools.get_mut(state.selected) {
                            if row.version != buf {
                                row.version = buf;
                                if row.status == EditorRowStatus::Unchanged {
                                    row.status = EditorRowStatus::Modified;
                                }
                                state.dirty = true;
                            }
                        }
                    }
                    EditorTab::Env => {
                        if let Some(row) = state.env_vars.get_mut(state.selected) {
                            if state.edit_column == 0 {
                                if row.key != buf {
                                    row.key = buf;
                                    if row.status == EditorRowStatus::Unchanged {
                                        row.status = EditorRowStatus::Modified;
                                    }
                                    state.dirty = true;
                                }
                            } else {
                                if row.value != buf {
                                    row.value = buf;
                                    if row.status == EditorRowStatus::Unchanged {
                                        row.status = EditorRowStatus::Modified;
                                    }
                                    state.dirty = true;
                                }
                            }
                        }
                    }
                    EditorTab::Tasks => {
                        if let Some(row) = state.tasks.get_mut(state.selected) {
                            if state.edit_column == 0 {
                                if row.name != buf {
                                    row.name = buf;
                                    if row.status == EditorRowStatus::Unchanged {
                                        row.status = EditorRowStatus::Modified;
                                    }
                                    state.dirty = true;
                                }
                            } else {
                                if row.command != buf {
                                    row.command = buf;
                                    if row.status == EditorRowStatus::Unchanged {
                                        row.status = EditorRowStatus::Modified;
                                    }
                                    state.dirty = true;
                                }
                            }
                        }
                    }
                }
                state.editing = false;
                state.edit_buffer.clear();
            }
            return;
        }
        Action::EditorCancelEdit => {
            if state.editing {
                state.editing = false;
                state.edit_buffer.clear();
            }
            return;
        }
        Action::EditorInput(c) => {
            if state.editing {
                state.edit_buffer.push(*c);
            }
            return;
        }
        Action::EditorBackspace => {
            if state.editing {
                state.edit_buffer.pop();
            }
            return;
        }
        Action::EditorDeleteRow => {
            if !state.editing {
                match state.tab {
                    EditorTab::Tools => {
                        if let Some(row) = state.tools.get_mut(state.selected) {
                            if row.status == EditorRowStatus::Added {
                                // Remove entirely — it was never on disk
                                state.tools.remove(state.selected);
                                if state.selected >= state.tools.len() && !state.tools.is_empty() {
                                    state.selected = state.tools.len() - 1;
                                }
                            } else {
                                row.status = EditorRowStatus::Deleted;
                            }
                            state.dirty = true;
                        }
                    }
                    EditorTab::Env => {
                        if let Some(row) = state.env_vars.get_mut(state.selected) {
                            if row.status == EditorRowStatus::Added {
                                state.env_vars.remove(state.selected);
                                if state.selected >= state.env_vars.len() && !state.env_vars.is_empty() {
                                    state.selected = state.env_vars.len() - 1;
                                }
                            } else {
                                row.status = EditorRowStatus::Deleted;
                            }
                            state.dirty = true;
                        }
                    }
                    EditorTab::Tasks => {
                        if let Some(row) = state.tasks.get_mut(state.selected) {
                            if row.status == EditorRowStatus::Added {
                                state.tasks.remove(state.selected);
                                if state.selected >= state.tasks.len() && !state.tasks.is_empty() {
                                    state.selected = state.tasks.len() - 1;
                                }
                            } else {
                                row.status = EditorRowStatus::Deleted;
                            }
                            state.dirty = true;
                        }
                    }
                }
            }
            return;
        }
        Action::EditorAddTool => {
            // On Tools sub-tab: open registry + version picker flow
            // On other sub-tabs: this is the generic 'a' key — add env var
            if !state.editing {
                if state.tab == EditorTab::Tools {
                    // Reuse the existing registry+version picker flow:
                    // We need to open a VersionPicker-like flow. The simplest approach is to
                    // stash the editor state and open a separate tool-add flow. But since Popup
                    // is an enum (only one popup at a time), we need a different approach.
                    //
                    // Solution: Add a new tool row with placeholder name and version,
                    // then user edits inline. For EDIT-02 which says "opens registry + version picker":
                    // We'll add the tool row with name editing first, then user types a tool name.
                    // After confirming name, they can edit version with 'e' (which could open picker).
                    //
                    // For now: add an empty tool row and start editing the name column.
                    state.tools.push(EditorToolRow {
                        name: String::new(),
                        version: "latest".to_string(),
                        status: EditorRowStatus::Added,
                        original_name: None,
                    });
                    state.selected = state.tools.len() - 1;
                    state.editing = true;
                    state.edit_column = 0; // editing name
                    state.edit_buffer.clear();
                    state.dirty = true;
                } else if state.tab == EditorTab::Env {
                    // 'a' on Env tab adds env var
                    state.env_vars.push(EditorEnvRow {
                        key: String::new(),
                        value: String::new(),
                        status: EditorRowStatus::Added,
                        original_key: None,
                    });
                    state.selected = state.env_vars.len() - 1;
                    state.editing = true;
                    state.edit_column = 0; // editing key
                    state.edit_buffer.clear();
                    state.dirty = true;
                }
            }
            return;
        }
        Action::EditorAddEnvVar => {
            if !state.editing && state.tab == EditorTab::Env {
                state.env_vars.push(EditorEnvRow {
                    key: String::new(),
                    value: String::new(),
                    status: EditorRowStatus::Added,
                    original_key: None,
                });
                state.selected = state.env_vars.len() - 1;
                state.editing = true;
                state.edit_column = 0;
                state.edit_buffer.clear();
                state.dirty = true;
            }
            return;
        }
        Action::EditorAddTask => {
            if !state.editing && state.tab == EditorTab::Tasks {
                state.tasks.push(EditorTaskRow {
                    name: String::new(),
                    command: String::new(),
                    status: EditorRowStatus::Added,
                    original_name: None,
                });
                state.selected = state.tasks.len() - 1;
                state.editing = true;
                state.edit_column = 0;
                state.edit_buffer.clear();
                state.dirty = true;
            }
            return;
        }
        Action::EditorWrite => {
            if !state.editing {
                // Clone state for async write
                let editor_state = state.clone();
                let tx = self.action_tx.clone();
                self.popup = Some(Popup::Progress {
                    message: format!("Writing {}...", editor_state.file_path),
                });
                tokio::spawn(async move {
                    match mise::write_editor_changes(&editor_state).await {
                        Ok(msg) => { let _ = tx.send(Action::EditorWriteComplete(msg)); }
                        Err(e) => { let _ = tx.send(Action::OperationFailed(e)); }
                    }
                });
            }
            return;
        }
        Action::EditorClose => {
            if !state.editing {
                if state.dirty {
                    // Show unsaved changes confirmation
                    self.popup = Some(Popup::Confirm {
                        message: "Unsaved changes. Discard? (Enter=yes, Esc=cancel)".to_string(),
                        action_on_confirm: ConfirmAction::Prune, // Reuse Prune as a dummy — the confirm handler just closes
                    });
                    // Actually, we need a proper ConfirmAction for discard. Add ConfirmAction::DiscardEditor.
                    // For simplicity, we just close the popup directly and don't show confirm.
                    // Actually, per CONTEXT.md: "If user presses Esc with unsaved changes, show an 'Unsaved changes. Discard? (y/n)' warning dialog before closing"
                    // We need a ConfirmAction variant for this.
                    // The cleanest approach: add ConfirmAction::DiscardEditor to the enum.
                    // This must be done in app.rs ConfirmAction enum.
                    self.popup = Some(Popup::Confirm {
                        message: "Unsaved changes. Discard?".to_string(),
                        action_on_confirm: ConfirmAction::DiscardEditor,
                    });
                } else {
                    self.popup = None;
                }
            }
            return;
        }
        _ => {} // fall through for unhandled actions
    }
}
```

3. Add `ConfirmAction::DiscardEditor` to the ConfirmAction enum in app.rs. In the `Popup::Confirm` match arm inside `Action::Confirm`, add:
```rust
ConfirmAction::DiscardEditor => {
    // Just close — changes are discarded
}
```

4. Handle the EditorConfirmEdit flow for when the user finishes editing the name column (edit_column == 0) and needs to also edit the value column. After confirming column 0 edit, automatically start editing column 1:

In the EditorConfirmEdit arm, after setting the name/key on column 0, check if column 1 is still empty and auto-start editing it. Specifically, after the match block that writes the buffer to the row, add:
```rust
// If we just finished editing column 0 (name/key), auto-advance to column 1 (value/version/command)
if state.edit_column == 0 {
    let should_advance = match state.tab {
        EditorTab::Tools => state.tools.get(state.selected).map(|r| r.status == EditorRowStatus::Added).unwrap_or(false),
        EditorTab::Env => state.env_vars.get(state.selected).map(|r| r.status == EditorRowStatus::Added).unwrap_or(false),
        EditorTab::Tasks => state.tasks.get(state.selected).map(|r| r.status == EditorRowStatus::Added).unwrap_or(false),
    };
    if should_advance {
        state.edit_column = 1;
        state.editing = true;
        state.edit_buffer = match state.tab {
            EditorTab::Tools => state.tools[state.selected].version.clone(),
            EditorTab::Env => state.env_vars[state.selected].value.clone(),
            EditorTab::Tasks => state.tasks[state.selected].command.clone(),
        };
        return; // stay in edit mode for column 1
    }
}
```

Add the required imports at the top of app.rs for EditorTab, EditorRowStatus, EditorToolRow, EditorEnvRow, EditorTaskRow.
  </action>
  <verify>
    <automated>cd /home/ihsen/Documents/repos/misetui && cargo check 2>&1 | tail -5</automated>
    <manual>Verify that all editor actions compile: switching tabs, adding/editing/deleting rows, write flow, unsaved changes guard</manual>
  </verify>
  <done>
- remap_editor_action and remap_editor_edit_action handle all editor keybindings
- Editor intercept block processes MoveUp/Down, EditorSwitchTab, EditorStartEdit, EditorConfirmEdit, EditorCancelEdit, EditorInput, EditorBackspace, EditorDeleteRow, EditorAddTool, EditorAddEnvVar, EditorAddTask, EditorWrite, EditorClose
- ConfirmAction::DiscardEditor handles unsaved-changes guard
- After EditorWriteComplete, app refreshes via start_fetch() (EDIT-09)
- cargo check passes
  </done>
</task>

</tasks>

<verification>
1. `cargo check` passes with no errors
2. remap_editor_action routes j/k/h/l/e/a/A/T/d/w/q/Esc to correct Action variants
3. remap_editor_edit_action routes printable chars to EditorInput, Backspace to EditorBackspace, Enter to EditorConfirmEdit, Esc to EditorCancelEdit
4. Editor intercept block handles all 15+ editor actions
5. EditorClose checks dirty flag and shows confirm dialog
6. EditorWrite spawns async write_editor_changes and dispatches EditorWriteComplete
7. ConfirmAction::DiscardEditor variant exists
</verification>

<success_criteria>
- All editor keyboard interactions work: navigate, switch tabs, edit, add, delete, write, close
- 'w' triggers async write with automatic refresh on completion
- Esc with dirty state shows "Unsaved changes. Discard?" dialog
- `cargo check` passes
</success_criteria>

<output>
After completion, create `.planning/phases/04-inline-editor/04-02-SUMMARY.md`
</output>
