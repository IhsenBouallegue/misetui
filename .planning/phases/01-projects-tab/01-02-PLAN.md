---
phase: 01-projects-tab
plan: 02
type: execute
wave: 2
depends_on:
  - 01-01
files_modified:
  - src/app.rs
  - src/action.rs
  - src/main.rs
  - src/mise.rs
autonomous: true
requirements:
  - PROJ-04
  - PROJ-05
  - PROJ-06
  - PROJ-07

must_haves:
  truths:
    - "Projects tab appears in the sidebar between Config and Doctor"
    - "Projects data loads asynchronously on startup and on r (rescan)"
    - "Fuzzy search with / filters project list by name and path"
    - "Pressing i on a selected project triggers mise install in that project directory"
    - "Pressing u on a selected project triggers mise upgrade in that project directory"
  artifacts:
    - path: "src/app.rs"
      provides: "Tab::Projects variant, projects/projects_state/projects_selected/filtered_projects/projects_hl fields, update_filtered_projects() method"
      contains: "Tab::Projects"
    - path: "src/action.rs"
      provides: "ProjectsLoaded, InstallProjectTools, UpdateProjectPins action variants"
      contains: "ProjectsLoaded"
    - path: "src/main.rs"
      provides: "mod config declaration, i and u keybindings on Projects tab"
      contains: "mod config"
    - path: "src/mise.rs"
      provides: "install_project_tools() and update_project_pins() async functions"
      contains: "install_project_tools"
  key_links:
    - from: "src/app.rs start_fetch()"
      to: "mise::scan_projects()"
      via: "tokio::spawn + action_tx.send(Action::ProjectsLoaded(...))"
      pattern: "ProjectsLoaded"
    - from: "src/app.rs handle_action(InstallProjectTools)"
      to: "mise::install_project_tools()"
      via: "tokio::spawn + OperationComplete/OperationFailed"
      pattern: "InstallProjectTools"
    - from: "src/main.rs remap_normal_action"
      to: "Action::InstallTool / Action::UpdateTool"
      via: "Tab context check in handle_action to route to project vs tool actions"
      pattern: "Tab::Projects"
---

<objective>
Wire the Projects tab into App state, the action system, and the event loop.

Purpose: After plan 01 establishes the data types, this plan connects everything: the Tab enum gains a Projects variant, App gains project data fields and filter arrays, async loading and rescan work, and i/u actions trigger mise operations in the project directory.

Output:
- `Tab::Projects` variant inserted between Config and Doctor in app.rs
- `App` struct gains projects data, state, selection, filter, and highlight cache fields
- `start_fetch()` spawns project scanner in background
- `handle_action()` handles ProjectsLoaded, InstallProjectTools, UpdateProjectPins
- `update_filtered_projects()` implements fuzzy search over name+path
- `install_project_tools()` and `update_project_pins()` in mise.rs
- `mod config` declared in main.rs
</objective>

<execution_context>
@/home/ihsen/.claude/get-shit-done/workflows/execute-plan.md
@/home/ihsen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@src/app.rs
@src/action.rs
@src/main.rs
@src/mise.rs
@src/model.rs
@.planning/phases/01-projects-tab/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Tab::Projects and App state fields</name>
  <files>src/app.rs, src/action.rs</files>
  <action>
    ## src/action.rs

    Add three new variants to the `Action` enum. Place `ProjectsLoaded` in the "Data loaded" section and the two operation actions in the "Operations" section:

    ```rust
    // Data loaded (add after ToolInfoLoaded):
    ProjectsLoaded(Vec<crate::model::MiseProject>),

    // Operations (add after ShowToolDetail):
    InstallProjectTools { path: String },
    UpdateProjectPins { path: String },
    ```

    Also add the MiseProject import at the top:
    ```rust
    use crate::model::{
        ConfigFile, EnvVar, InstalledTool, MiseSetting, MiseProject, MiseTask, OutdatedTool, PruneCandidate, RegistryEntry,
    };
    ```

    ## src/app.rs

    **1. Update Tab enum** — Insert `Projects` between `Config` and `Doctor`:

    Change `Tab::ALL` from 8 entries to 9 entries:
    ```rust
    pub const ALL: [Tab; 9] = [
        Tab::Tools,
        Tab::Outdated,
        Tab::Registry,
        Tab::Tasks,
        Tab::Environment,
        Tab::Settings,
        Tab::Config,
        Tab::Projects,  // NEW — inserted here
        Tab::Doctor,
    ];
    ```

    Add `Tab::Projects` variant to the enum. Update `label()` and `index()`:
    ```rust
    Tab::Projects => " Projects",   // label
    Tab::Projects => 7,             // index (Config=6, Projects=7, Doctor=8)
    ```
    Update Doctor's index from 7 to 8.

    **2. Update model import** — Add `MiseProject` to the use statement at top of app.rs.

    **3. Add App struct fields** (after the existing `settings: Vec<MiseSetting>` field):
    ```rust
    pub projects: Vec<MiseProject>,
    ```

    Add load state after `settings_state`:
    ```rust
    pub projects_state: LoadState,
    ```

    Add selection index after `settings_selected`:
    ```rust
    pub projects_selected: usize,
    pub projects_drill_selected: usize,  // selection within drill-down tool list
    pub projects_drill_active: bool,     // true when viewing tool breakdown for a project
    ```

    Add filter arrays after `filtered_settings`:
    ```rust
    pub filtered_projects: Vec<usize>,
    ```

    Add highlight cache after `settings_hl`:
    ```rust
    pub projects_hl: Vec<Vec<usize>>,
    ```

    **4. Update App::new()** — Initialize all new fields with sensible defaults:
    ```rust
    projects: Vec::new(),
    projects_state: LoadState::Loading,
    projects_selected: 0,
    projects_drill_selected: 0,
    projects_drill_active: false,
    filtered_projects: Vec::new(),
    projects_hl: Vec::new(),
    ```

    **5. Add update_filtered_projects() method** — following the same pattern as `update_filtered_tools()`. Fuzzy match on `project.name` (primary) and also try matching on `project.path` (use best score of the two). Store indices sorted descending by score with highlight indices from name match:

    ```rust
    fn update_filtered_projects(&mut self) {
        if !self.search_active || self.search_query.is_empty() {
            self.filtered_projects = (0..self.projects.len()).collect();
            self.projects_hl = self.filtered_projects.iter().map(|_| Vec::new()).collect();
            return;
        }
        let matcher = SkimMatcherV2::default();
        let query = &self.search_query;
        let mut scored: Vec<(i64, usize, Vec<usize>)> = self
            .projects
            .iter()
            .enumerate()
            .filter_map(|(i, proj)| {
                let name_score = matcher.fuzzy_indices(&proj.name, query);
                let path_score = matcher.fuzzy_indices(&proj.path, query);
                // Use the better score of name vs path; highlight indices from name match
                match (name_score, path_score) {
                    (Some((ns, ni)), Some((ps, _))) if ns >= ps => Some((ns, i, ni)),
                    (Some((ns, ni)), None) => Some((ns, i, ni)),
                    (None, Some((ps, _pi))) => Some((ps, i, Vec::new())),
                    (Some((ns, ni)), Some(_)) => Some((ns, i, ni)),
                    _ => None,
                }
            })
            .collect();
        scored.sort_by(|a, b| b.0.cmp(&a.0));
        self.filtered_projects = scored.iter().map(|(_, i, _)| *i).collect();
        self.projects_hl = scored.into_iter().map(|(_, _, hl)| hl).collect();
    }
    ```

    **6. Add to update_all_filters()** — Append a call to `self.update_filtered_projects()` at the end of the existing `update_all_filters()` method.

    **7. Handle ProjectsLoaded in handle_action()** — Add in the "Data loaded" match section:
    ```rust
    Action::ProjectsLoaded(projects) => {
        self.projects = projects;
        self.projects_state = LoadState::Loaded;
        self.update_filtered_projects();
    }
    ```

    **8. Handle InstallProjectTools and UpdateProjectPins in handle_action()** — Add in the "Operations" section. Check that current tab is Projects and a project is selected, then spawn async task:
    ```rust
    Action::InstallProjectTools { path } => {
        self.popup = Some(Popup::Progress {
            message: format!("Installing tools in {}...", path),
        });
        let tx = self.action_tx.clone();
        tokio::spawn(async move {
            match mise::install_project_tools(&path).await {
                Ok(msg) => { let _ = tx.send(Action::OperationComplete(msg)); }
                Err(e)  => { let _ = tx.send(Action::OperationFailed(e)); }
            }
        });
    }
    Action::UpdateProjectPins { path } => {
        self.popup = Some(Popup::Progress {
            message: format!("Upgrading tools in {}...", path),
        });
        let tx = self.action_tx.clone();
        tokio::spawn(async move {
            match mise::update_project_pins(&path).await {
                Ok(msg) => { let _ = tx.send(Action::OperationComplete(msg)); }
                Err(e)  => { let _ = tx.send(Action::OperationFailed(e)); }
            }
        });
    }
    ```

    **9. Handle i and u on Projects tab in handle_action()** — Inside the existing `Action::InstallTool` match arm, add a branch for Tab::Projects:
    ```rust
    Action::InstallTool => {
        match self.tab {
            Tab::Projects => {
                if let Some(&idx) = self.filtered_projects.get(self.projects_selected) {
                    let path = self.projects[idx].path.clone();
                    self.handle_action(Action::InstallProjectTools { path });
                }
            }
            // ... existing tool install logic ...
        }
    }
    Action::UpdateTool => {
        match self.tab {
            Tab::Projects => {
                if let Some(&idx) = self.filtered_projects.get(self.projects_selected) {
                    let path = self.projects[idx].path.clone();
                    self.handle_action(Action::UpdateProjectPins { path });
                }
            }
            // ... existing update tool logic ...
        }
    }
    ```

    **10. Handle Enter (Confirm) on Projects tab** to toggle drill-down. In the `Action::Confirm` arm, add a branch for Tab::Projects:
    ```rust
    Tab::Projects => {
        if self.projects_drill_active {
            self.projects_drill_active = false;
            self.projects_drill_selected = 0;
        } else {
            self.projects_drill_active = true;
            self.projects_drill_selected = 0;
        }
    }
    ```

    **11. Handle MoveUp/MoveDown for drill-down** — In move_selection(), add logic: when tab is Projects and drill_active is true, navigate projects_drill_selected within the selected project's tools list instead of navigating projects_selected.

    **12. Handle reset_selection_for_tab()** — Add `Tab::Projects => self.projects_selected = 0` and also reset `projects_drill_active = false`.
  </action>
  <verify>
    <automated>cargo build 2>&1 | grep -E "^error" | head -20</automated>
    <manual>Run `cargo build`. Check that all Tab::ALL, label(), index() match arms are updated for Tab::Projects (9 variants now).</manual>
  </verify>
  <done>cargo build succeeds. Tab::Projects is at index 7, Doctor is at index 8. App struct has all projects-related fields. Action enum has ProjectsLoaded, InstallProjectTools, UpdateProjectPins variants.</done>
</task>

<task type="auto">
  <name>Task 2: Wire start_fetch(), config module, and mise.rs operations</name>
  <files>src/app.rs, src/main.rs, src/mise.rs</files>
  <action>
    ## src/main.rs

    Add `mod config;` at the top alongside the other mod declarations (before `use action::Action`):
    ```rust
    mod config;
    ```

    ## src/mise.rs

    Add two new async functions at the bottom of mise.rs:

    ```rust
    /// Run `mise install` in the specified project directory.
    pub async fn install_project_tools(path: &str) -> Result<String, String> {
        let output = Command::new("mise")
            .args(["install"])
            .current_dir(path)
            .output()
            .await
            .map_err(|e| format!("Failed to run mise install: {e}"))?;

        if output.status.success() {
            Ok(format!("Installed tools in {path}"))
        } else {
            let stderr = String::from_utf8_lossy(&output.stderr).to_string();
            Err(format!("mise install failed: {stderr}"))
        }
    }

    /// Run `mise upgrade` in the specified project directory to update outdated tool pins.
    pub async fn update_project_pins(path: &str) -> Result<String, String> {
        let output = Command::new("mise")
            .args(["upgrade"])
            .current_dir(path)
            .output()
            .await
            .map_err(|e| format!("Failed to run mise upgrade: {e}"))?;

        if output.status.success() {
            Ok(format!("Updated tool pins in {path}"))
        } else {
            let stderr = String::from_utf8_lossy(&output.stderr).to_string();
            Err(format!("mise upgrade failed: {stderr}"))
        }
    }
    ```

    ## src/app.rs

    **Update start_fetch()** to spawn the project scanner. Add the following block to the end of `start_fetch()`, after the settings spawn:

    ```rust
    // Projects: load config and scan synchronously inside spawn (filesystem I/O only)
    let tx = self.action_tx.clone();
    // Clone the tools snapshot for cross-referencing; it may be empty on first fetch
    // (that's fine — projects will rescan on next refresh after tools load)
    let tools_snapshot = self.tools.clone();
    tokio::spawn(async move {
        let config = crate::config::MisetuiConfig::load();
        let projects = mise::scan_projects(&config, &tools_snapshot);
        let _ = tx.send(Action::ProjectsLoaded(projects));
    });
    ```

    **Update OperationComplete handler** — After an operation completes (end of Action::OperationComplete arm), call start_fetch() to refresh project health. The existing code already calls start_fetch() or refreshes relevant data; ensure projects are refreshed too. The existing `start_fetch()` call in OperationComplete already covers this if we add the projects spawn there.

    **Update Action::Refresh handler** — The existing Refresh arm calls `start_fetch()`. Since start_fetch() now includes the projects spawn, `r` automatically rescans projects. Verify this is the case (no additional change needed if start_fetch is correct).
  </action>
  <verify>
    <automated>cargo build 2>&1 | grep -E "^error" | head -20</automated>
    <manual>After build, run `cargo run` and check that the app starts without panic. The Projects tab should appear in the sidebar between Config and Doctor (even if it shows a loading spinner since no UI renderer exists yet).</manual>
  </verify>
  <done>cargo build succeeds. mod config is declared in main.rs. install_project_tools() and update_project_pins() exist in mise.rs. start_fetch() spawns project scan. The app starts without crashing (sidebar shows Projects tab at position 8 between Config and Doctor).</done>
</task>

</tasks>

<verification>
`cargo build` exits 0. The sidebar should show 9 tabs (Tools, Outdated, Registry, Tasks, Environment, Settings, Config, Projects, Doctor) when the app is run. Projects loads asynchronously. Fuzzy search updates filtered_projects. i and u dispatch install/update operations with Progress popup.
</verification>

<success_criteria>
- `cargo build` exits 0 with no errors
- Tab::Projects exists in src/app.rs at index 7 (Doctor shifts to 8)
- Tab::ALL has 9 entries
- App struct has: projects, projects_state, projects_selected, projects_drill_active, projects_drill_selected, filtered_projects, projects_hl
- Action enum has: ProjectsLoaded, InstallProjectTools { path }, UpdateProjectPins { path }
- start_fetch() spawns project scan using MisetuiConfig::load()
- mise.rs has install_project_tools() and update_project_pins() with current_dir support
</success_criteria>

<output>
After completion, create `.planning/phases/01-projects-tab/01-02-SUMMARY.md` following the summary template.
</output>
