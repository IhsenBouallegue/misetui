---
phase: 03-bootstrap-wizard
plan: 02
type: execute
wave: 2
depends_on:
  - 03-01
files_modified:
  - src/app.rs
  - src/action.rs
  - src/main.rs
  - src/mise.rs
autonomous: true
requirements:
  - BOOT-01
  - BOOT-04
  - BOOT-05
  - BOOT-06
  - BOOT-07

must_haves:
  truths:
    - "Pressing B from any tab (when no popup is open) opens the Bootstrap Wizard"
    - "Wizard detects tools, enters Review step, user can toggle tools with Space/t and navigate with j/k"
    - "Pressing Enter in Review step generates preview content and transitions to Preview step"
    - "Pressing Enter in Preview step triggers file write + mise install in target dir"
    - "AGENTS.md and CLAUDE.md are written when write_agent_files toggle is on"
    - "WizardCompleted action refreshes app data after successful write"
  artifacts:
    - path: "src/action.rs"
      provides: "OpenWizard, WizardDetected, WizardCompleted, WizardToggleTool, WizardToggleAgentFiles, WizardNextStep, WizardPrevStep actions"
      contains: "OpenWizard"
    - path: "src/app.rs"
      provides: "Popup::Wizard(WizardState) variant, handle_action arms for all Wizard* actions"
      contains: "Popup::Wizard"
    - path: "src/main.rs"
      provides: "B keybinding → OpenWizard, remap_wizard_action for j/k/Space/Enter/Esc in wizard mode"
      contains: "OpenWizard"
    - path: "src/mise.rs"
      provides: "write_mise_toml(), run_mise_install_in(), write_agent_files_for()"
      contains: "pub async fn write_mise_toml"
  key_links:
    - from: "src/main.rs"
      to: "src/app.rs"
      via: "remap_wizard_action → handle_action dispatch"
      pattern: "is_wizard_active"
    - from: "src/app.rs"
      to: "src/mise.rs"
      via: "tokio::spawn calls write_mise_toml, run_mise_install_in, write_agent_files_for"
      pattern: "write_mise_toml"
    - from: "src/app.rs"
      to: "src/model.rs"
      via: "Popup::Wizard(WizardState) uses WizardState, DetectedTool, WizardStep"
      pattern: "WizardState"
---

<objective>
Wire the Bootstrap Wizard into the running app: Action enum additions, Popup::Wizard variant, keybinding, step navigation, write/install side-effects.

Purpose: Makes the wizard interactive — user can open it with B, review detected tools, preview the config, and trigger the write + install.
Output: Full Action routing, handle_action arms, and the three async mise functions that do the actual file I/O and install.
</objective>

<execution_context>
@/home/ihsen/.claude/get-shit-done/workflows/execute-plan.md
@/home/ihsen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-bootstrap-wizard/03-01-SUMMARY.md
@src/action.rs
@src/app.rs
@src/main.rs
@src/mise.rs
@src/model.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Wizard actions to action.rs and Popup::Wizard to app.rs, plus write/install functions to mise.rs</name>
  <files>src/action.rs, src/app.rs, src/mise.rs</files>
  <action>
**src/action.rs** — Add the following variants to the Action enum (after the existing JumpToDriftProject line):

```rust
    // Bootstrap Wizard
    OpenWizard,
    WizardDetected(Vec<crate::model::DetectedTool>),
    WizardToggleTool,
    WizardToggleAgentFiles,
    WizardNextStep,
    WizardPrevStep,
    WizardCompleted(String),
```

Also add `DetectedTool` to the existing `use crate::model::{ ... }` import at the top.

**src/app.rs** — Three changes:

1. Add `WizardState` and `WizardStep` to the existing `use crate::model::{ ... }` import.

2. Add `Popup::Wizard` variant to the existing `pub enum Popup` — add it after `ScanConfig { ... }`:

```rust
    Wizard(crate::model::WizardState),
```

3. In `handle_action`, add the Wizard intercept block before the main `match action` statement (after the existing ScanConfig intercept block). Pattern follows the ScanConfig intercept block:

```rust
        // Wizard popup intercepts navigation when wizard is active
        if let Some(Popup::Wizard(ref mut wizard)) = self.popup {
            match &action {
                Action::MoveUp => {
                    if wizard.step == WizardStep::Review && wizard.selected > 0 {
                        wizard.selected -= 1;
                    } else if wizard.step == WizardStep::Preview && wizard.preview_scroll > 0 {
                        wizard.preview_scroll -= 1;
                    }
                    return;
                }
                Action::MoveDown => {
                    if wizard.step == WizardStep::Review {
                        if wizard.selected + 1 < wizard.tools.len() {
                            wizard.selected += 1;
                        }
                    } else if wizard.step == WizardStep::Preview {
                        wizard.preview_scroll += 1;
                    }
                    return;
                }
                Action::WizardToggleTool => {
                    if wizard.step == WizardStep::Review {
                        if let Some(tool) = wizard.tools.get_mut(wizard.selected) {
                            tool.enabled = !tool.enabled;
                        }
                    }
                    return;
                }
                Action::WizardToggleAgentFiles => {
                    if wizard.step == WizardStep::Review {
                        wizard.write_agent_files = !wizard.write_agent_files;
                    }
                    return;
                }
                Action::WizardNextStep | Action::Confirm => {
                    match wizard.step {
                        WizardStep::Detecting => {
                            // do nothing — waiting for WizardDetected
                        }
                        WizardStep::Review => {
                            // Generate preview, advance to Preview step
                            let preview = generate_mise_toml_preview(&wizard.tools);
                            wizard.preview_content = preview;
                            wizard.step = WizardStep::Preview;
                            wizard.preview_scroll = 0;
                        }
                        WizardStep::Preview => {
                            // Trigger write + install
                            let target = wizard.target_dir.clone();
                            let tools: Vec<_> = wizard.tools.iter()
                                .filter(|t| t.enabled)
                                .map(|t| (t.name.clone(), t.version.clone()))
                                .collect();
                            let agent_files = wizard.write_agent_files;
                            wizard.step = WizardStep::Writing;
                            let tx = self.action_tx.clone();
                            tokio::spawn(async move {
                                match mise::write_mise_toml(&target, &tools).await {
                                    Ok(()) => {}
                                    Err(e) => {
                                        let _ = tx.send(Action::OperationFailed(e));
                                        return;
                                    }
                                }
                                if agent_files {
                                    let _ = mise::write_agent_files_for(&target).await;
                                }
                                match mise::run_mise_install_in(&target).await {
                                    Ok(msg) => { let _ = tx.send(Action::WizardCompleted(msg)); }
                                    Err(e)  => { let _ = tx.send(Action::OperationFailed(e)); }
                                }
                            });
                        }
                        WizardStep::Writing => {}
                    }
                    return;
                }
                Action::WizardPrevStep => {
                    match wizard.step {
                        WizardStep::Preview => {
                            wizard.step = WizardStep::Review;
                        }
                        _ => {}
                    }
                    return;
                }
                Action::CancelPopup => {
                    self.popup = None;
                    return;
                }
                _ => {}
            }
        }
```

4. Add the following handle_action arms after the existing `Action::OpenScanConfig` arm (inside the main `match action` block):

```rust
            Action::OpenWizard => {
                if self.popup.is_some() {
                    return;
                }
                let target = std::env::current_dir()
                    .unwrap_or_else(|_| std::path::PathBuf::from("."))
                    .to_string_lossy()
                    .to_string();
                self.popup = Some(Popup::Wizard(crate::model::WizardState {
                    target_dir: target.clone(),
                    step: crate::model::WizardStep::Detecting,
                    tools: Vec::new(),
                    selected: 0,
                    preview_content: String::new(),
                    write_agent_files: false,
                    preview_scroll: 0,
                }));
                // Spawn detection on background thread (filesystem I/O)
                let tx = self.action_tx.clone();
                tokio::spawn(async move {
                    let tools = mise::detect_project_tools(&target);
                    let _ = tx.send(Action::WizardDetected(tools));
                });
            }
            Action::WizardDetected(tools) => {
                if let Some(Popup::Wizard(ref mut wizard)) = self.popup {
                    wizard.tools = tools;
                    wizard.step = crate::model::WizardStep::Review;
                    wizard.selected = 0;
                }
            }
            Action::WizardCompleted(msg) => {
                self.popup = None;
                self.status_message = Some((msg, 30));
                self.start_fetch();
            }
            // These are handled by the intercept block; arms here prevent non-exhaustive match errors
            Action::WizardToggleTool
            | Action::WizardToggleAgentFiles
            | Action::WizardNextStep
            | Action::WizardPrevStep => {}
```

5. Add a helper function `generate_mise_toml_preview` at the bottom of app.rs (after the impl App block, as a free function, or as a private `fn` inside `impl App`). Place it just before the closing `}` of `impl App`:

```rust
    fn generate_mise_toml_preview_fn(tools: &[crate::model::DetectedTool]) -> String {
        // This fn is called as a free function via generate_mise_toml_preview()
        // placed below — see below.
        let _ = tools;
        String::new()
    }
```

Actually: add as a standalone free function OUTSIDE the impl App block (at the end of app.rs):

```rust
/// Build the .mise.toml content string from a list of enabled tools.
/// Called by the wizard intercept block to populate preview_content.
fn generate_mise_toml_preview(tools: &[crate::model::DetectedTool]) -> String {
    let mut lines = vec!["[tools]".to_string()];
    for tool in tools.iter().filter(|t| t.enabled) {
        if tool.version.is_empty() || tool.version == "latest" {
            lines.push(format!("{} = \"latest\"", tool.name));
        } else {
            lines.push(format!("{} = \"{}\"", tool.name, tool.version));
        }
    }
    lines.join("\n") + "\n"
}
```

**src/mise.rs** — Append three new async functions at the end of mise.rs:

```rust
/// Write a .mise.toml file to `dir` with the given tool name/version pairs.
/// Overwrites any existing .mise.toml. Uses atomic write (temp file + rename).
pub async fn write_mise_toml(dir: &str, tools: &[(String, String)]) -> Result<(), String> {
    use std::path::Path;
    let path = Path::new(dir).join(".mise.toml");
    let tmp_path = Path::new(dir).join(".mise.toml.tmp");

    let mut content = String::from("[tools]\n");
    for (name, version) in tools {
        if version.is_empty() || version == "latest" {
            content.push_str(&format!("{name} = \"latest\"\n"));
        } else {
            content.push_str(&format!("{name} = \"{version}\"\n"));
        }
    }

    tokio::fs::write(&tmp_path, &content)
        .await
        .map_err(|e| format!("Failed to write temp file: {e}"))?;
    tokio::fs::rename(&tmp_path, &path)
        .await
        .map_err(|e| format!("Failed to rename temp file: {e}"))?;
    Ok(())
}

/// Run `mise install` in `dir` and return a success message or error.
pub async fn run_mise_install_in(dir: &str) -> Result<String, String> {
    let output = tokio::process::Command::new("mise")
        .args(["install"])
        .current_dir(dir)
        .output()
        .await
        .map_err(|e| format!("Failed to run mise install: {e}"))?;

    if output.status.success() {
        Ok(format!("Bootstrapped {} — mise install complete", dir))
    } else {
        let stderr = String::from_utf8_lossy(&output.stderr).to_string();
        Err(format!("mise install failed: {stderr}"))
    }
}

/// Write AGENTS.md and CLAUDE.md to `dir` with mise-specific agent instructions.
/// Silently ignores write errors (non-critical optional feature — BOOT-07).
pub async fn write_agent_files_for(dir: &str) -> Result<(), String> {
    use std::path::Path;
    let base = Path::new(dir);

    let agents_content = "\
# Agent Instructions

## mise — Dev Tool Version Manager

This project uses [mise](https://mise.jdx.dev/) to manage tool versions.

### Installing tools
```
mise install
```

### Running tasks
```
mise run <task-name>
mise tasks ls
```

### Checking environment
```
mise status
mise ls
```

### Pinned versions
Tool versions are pinned in `.mise.toml`. Always use the pinned version when running tools.
Do not upgrade tool versions without updating `.mise.toml`.
";

    let claude_content = "\
# Claude Code Instructions

## Tool version management

This project uses mise. Run `mise install` before starting work in a new terminal.
Check `.mise.toml` for pinned tool versions — use these exact versions.

## Running tasks

```
mise run <task>   # run a mise task
mise tasks ls     # list all tasks
```

Do not use global tool versions that differ from `.mise.toml` pins.
";

    let agents_path = base.join("AGENTS.md");
    let claude_path = base.join("CLAUDE.md");

    let _ = tokio::fs::write(&agents_path, agents_content).await;
    let _ = tokio::fs::write(&claude_path, claude_content).await;
    Ok(())
}
```
  </action>
  <verify>
    <automated>cd /home/ihsen/Documents/repos/misetui && cargo check 2>&1 | head -40</automated>
    <manual>Confirm Popup::Wizard variant exists, Action::OpenWizard exists, B key not yet wired (that is Task 2).</manual>
  </verify>
  <done>cargo check passes; Action::OpenWizard, Popup::Wizard, and all handle_action arms compile without errors.</done>
</task>

<task type="auto">
  <name>Task 2: Wire B keybinding and remap_wizard_action in main.rs</name>
  <files>src/main.rs</files>
  <action>
**src/main.rs** — Four changes:

1. Add `Action::OpenWizard` to the imports at the top (already has `use action::Action;` — no change needed there; Action variants are accessed via the enum).

2. Add `WizardState`, `WizardStep` to the `use app::{App, Popup};` import:
   Change: `use app::{App, Popup};`
   To: `use app::{App, Popup};`  (no change needed — Popup::Wizard holds WizardState inline)

3. In the event loop `tokio::select!` block, add `is_wizard_active` check to the remap chain. The current chain is:
```rust
let action = if is_version_picker_active(&app) {
    remap_version_picker_action(event_action)
} else if is_scan_config_active(&app) {
    remap_scan_config_action(event_action)
} else if app.search_active && app.popup.is_none() {
    remap_search_action(event_action)
} else {
    remap_normal_action(event_action)
};
```
Change to:
```rust
let action = if is_version_picker_active(&app) {
    remap_version_picker_action(event_action)
} else if is_scan_config_active(&app) {
    remap_scan_config_action(event_action)
} else if is_wizard_active(&app) {
    remap_wizard_action(event_action)
} else if app.search_active && app.popup.is_none() {
    remap_search_action(event_action)
} else {
    remap_normal_action(event_action)
};
```

4. Add the `is_wizard_active` helper function near the other `is_*_active` helpers:
```rust
fn is_wizard_active(app: &App) -> bool {
    matches!(app.popup, Some(Popup::Wizard(_)))
}
```

5. Add the `remap_wizard_action` function after `remap_scan_config_action`:
```rust
/// In wizard popup mode, route chars to wizard navigation actions
fn remap_wizard_action(action: Action) -> Action {
    match action {
        Action::SearchInput(c) => match c {
            'j' => Action::MoveDown,
            'k' => Action::MoveUp,
            ' ' => Action::WizardToggleTool,
            'a' => Action::WizardToggleAgentFiles,
            'n' => Action::WizardNextStep,
            'p' => Action::WizardPrevStep,
            'q' | 'Q' => Action::CancelPopup,
            _ => Action::None,
        },
        Action::Confirm => Action::WizardNextStep,
        Action::CancelPopup => Action::CancelPopup,
        Action::MoveUp | Action::MoveDown | Action::PageUp | Action::PageDown => action,
        _ => Action::None,
    }
}
```

6. In `remap_normal_action`, add `'B' => Action::OpenWizard,` to the match arm list (after the existing `'c' => Action::OpenScanConfig,` line):
```rust
'B' => Action::OpenWizard,
```
  </action>
  <verify>
    <automated>cd /home/ihsen/Documents/repos/misetui && cargo check 2>&1 | head -40</automated>
    <manual>Confirm remap_wizard_action function exists, B keybinding is in remap_normal_action, is_wizard_active helper exists.</manual>
  </verify>
  <done>cargo check passes; B keybinding and wizard remap function are wired in main.rs. The app compiles fully with no errors.</done>
</task>

</tasks>

<verification>
Run `cargo check` — zero errors. Grep for `OpenWizard` in src/action.rs, src/app.rs, src/main.rs — must appear in all three. Grep for `write_mise_toml` in src/mise.rs — must be present.
</verification>

<success_criteria>
- cargo check passes with zero errors
- Action::OpenWizard, WizardDetected, WizardToggleTool, WizardToggleAgentFiles, WizardNextStep, WizardPrevStep, WizardCompleted exist
- Popup::Wizard(WizardState) variant exists in app.rs
- Wizard intercept block handles all wizard-mode keypresses
- B keybinding in remap_normal_action maps to OpenWizard
- remap_wizard_action handles j/k/Space/Enter/Esc
- write_mise_toml, run_mise_install_in, write_agent_files_for in mise.rs
</success_criteria>

<output>
After completion, create `.planning/phases/03-bootstrap-wizard/03-02-SUMMARY.md` following the summary template.
</output>
