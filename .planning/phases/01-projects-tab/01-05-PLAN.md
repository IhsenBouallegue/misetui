---
phase: 01-projects-tab
plan: 05
type: execute
wave: 5
depends_on:
  - 01-03
files_modified:
  - src/action.rs
  - src/app.rs
  - src/config.rs
  - src/main.rs
  - src/ui/popup.rs
autonomous: true
requirements:
  - PROJ-08

must_haves:
  truths:
    - "Pressing c on the Projects tab opens a scan config popup showing current scan_dirs and max_depth"
    - "User can add and remove scan directories from inside the popup"
    - "User can increase/decrease max_depth with + and - keys"
    - "Saving writes to ~/.config/misetui/config.toml and triggers an immediate rescan"
    - "Closing with Esc discards any changes"
  artifacts:
    - path: "src/app.rs"
      provides: "Popup::ScanConfig variant with editing state"
      contains: "ScanConfig"
    - path: "src/config.rs"
      provides: "MisetuiConfig::save() writes TOML to ~/.config/misetui/config.toml"
      contains: "pub fn save"
    - path: "src/ui/popup.rs"
      provides: "render_scan_config() popup renderer"
      contains: "render_scan_config"
  key_links:
    - from: "src/main.rs remap_normal_action"
      to: "Action::OpenScanConfig"
      via: "'c' => Action::OpenScanConfig"
      pattern: "OpenScanConfig"
    - from: "src/app.rs handle_action(SaveScanConfig)"
      to: "config::MisetuiConfig::save()"
      via: "writes to disk then calls start_fetch()"
      pattern: "SaveScanConfig"
---

<objective>
Add in-app scan configuration editing (PROJ-08): pressing `c` on the Projects tab opens a popup where the user can add/remove scan directories and adjust max_depth, then save to `~/.config/misetui/config.toml` with an immediate rescan.

Purpose: Currently scan dirs and max_depth can only be configured by manually editing the config file. This popup provides in-app editing without leaving the TUI.
</objective>

<execution_context>
@/home/ihsen/.claude/get-shit-done/workflows/execute-plan.md
@/home/ihsen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@src/action.rs
@src/app.rs
@src/config.rs
@src/main.rs
@src/ui/popup.rs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ScanConfig popup state, actions, config save, and event routing</name>
  <files>src/action.rs, src/app.rs, src/config.rs, src/main.rs</files>
  <action>
    ## src/action.rs

    Add two new action variants in the Operations section:
    ```rust
    OpenScanConfig,
    SaveScanConfig,
    ```

    ## src/config.rs

    1. Add `Serialize` to the derive on `MisetuiConfig`:
    ```rust
    #[derive(Debug, Clone, Deserialize, Serialize)]
    pub struct MisetuiConfig {
    ```

    2. Add `pub fn save(&self) -> Result<(), String>` after `load()`:
    ```rust
    /// Save to ~/.config/misetui/config.toml. Creates directories if needed.
    pub fn save(&self) -> Result<(), String> {
        let config_path = dirs::config_dir()
            .map(|d| d.join("misetui").join("config.toml"))
            .ok_or_else(|| "Could not determine config directory".to_string())?;

        if let Some(parent) = config_path.parent() {
            std::fs::create_dir_all(parent)
                .map_err(|e| format!("Failed to create config dir: {e}"))?;
        }

        let contents = toml::to_string_pretty(self)
            .map_err(|e| format!("Failed to serialize config: {e}"))?;

        std::fs::write(&config_path, contents)
            .map_err(|e| format!("Failed to write config: {e}"))?;

        Ok(())
    }
    ```

    Note: `scan_dirs` is `Vec<PathBuf>` — toml serializes PathBuf as a string, which is correct.

    ## src/app.rs

    **1. Add `ScanConfig` variant to `Popup` enum** (after `Help`):
    ```rust
    ScanConfig {
        /// Working copy of scan dirs being edited.
        dirs: Vec<String>,
        /// Currently highlighted dir in the list.
        selected: usize,
        /// When true, user is typing a new directory path.
        adding: bool,
        /// Text buffer for the new directory path being typed.
        new_dir: String,
        /// Working copy of max_depth being edited.
        max_depth: usize,
    },
    ```

    **2. Handle `Action::OpenScanConfig`** — add a match arm in `handle_action()`. Only open when on the Projects tab and no popup is already open:
    ```rust
    Action::OpenScanConfig => {
        if self.tab != Tab::Projects || self.popup.is_some() {
            return;
        }
        let config = crate::config::MisetuiConfig::load();
        let dirs = config.scan_dirs.iter()
            .map(|p| p.to_string_lossy().to_string())
            .collect();
        self.popup = Some(Popup::ScanConfig {
            dirs,
            selected: 0,
            adding: false,
            new_dir: String::new(),
            max_depth: config.max_depth,
        });
    }
    ```

    **3. Handle `Action::SaveScanConfig`** — build a new `MisetuiConfig`, save it, trigger rescan:
    ```rust
    Action::SaveScanConfig => {
        if let Some(Popup::ScanConfig { dirs, max_depth, .. }) = &self.popup {
            let dirs_clone: Vec<_> = dirs.iter()
                .filter(|d| !d.trim().is_empty())
                .map(|d| std::path::PathBuf::from(d))
                .collect();
            let max_depth = *max_depth;
            let config = crate::config::MisetuiConfig {
                scan_dirs: dirs_clone,
                max_depth,
            };
            match config.save() {
                Ok(()) => {
                    self.popup = None;
                    // Rescan with updated config
                    let tx = self.action_tx.clone();
                    let tools_snapshot = self.tools.clone();
                    tokio::spawn(async move {
                        let cfg = crate::config::MisetuiConfig::load();
                        let projects = crate::mise::scan_projects(&cfg, &tools_snapshot);
                        let _ = tx.send(Action::ProjectsLoaded(projects));
                    });
                }
                Err(e) => {
                    self.popup = Some(Popup::Progress {
                        message: format!("Save failed: {e}"),
                    });
                }
            }
        }
    }
    ```

    **4. Handle in-popup navigation for `ScanConfig`** — add handling in the existing key-dispatch area. These actions arrive via `remap_scan_config_action` (see main.rs below). The actions that need to be handled inside the ScanConfig popup:

    In `handle_action`, add a guard block BEFORE other action handling: when `self.popup` is `Some(Popup::ScanConfig { .. })`, intercept `MoveUp`, `MoveDown`, `UninstallTool` (mapped from `d`), `InstallTool` (mapped from `a`), `Confirm` (Enter), `CancelPopup` (Esc), and `SearchInput('+')` / `SearchInput('-')` / `SearchInput` (for typing new dir), `SearchBackspace`:

    ```rust
    // ScanConfig popup intercepts navigation before the main action switch
    if let Some(Popup::ScanConfig { dirs, selected, adding, new_dir, max_depth }) = &mut self.popup {
        match &action {
            Action::MoveUp => {
                if !*adding && *selected > 0 { *selected -= 1; }
                return;
            }
            Action::MoveDown => {
                if !*adding && *selected + 1 < dirs.len() { *selected += 1; }
                return;
            }
            // 'd' mapped to UninstallTool in remap_scan_config_action
            Action::UninstallTool => {
                if !*adding && !dirs.is_empty() {
                    dirs.remove(*selected);
                    if *selected >= dirs.len() && !dirs.is_empty() { *selected = dirs.len() - 1; }
                }
                return;
            }
            // 'a' mapped to InstallTool
            Action::InstallTool => {
                if !*adding { *adding = true; new_dir.clear(); }
                return;
            }
            // '+' increases max_depth, '-' decreases (sent as SearchInput when adding=false)
            Action::SearchInput('+') if !*adding => {
                *max_depth += 1;
                return;
            }
            Action::SearchInput('-') if !*adding && *max_depth > 1 => {
                *max_depth -= 1;
                return;
            }
            // Typing when adding=true
            Action::SearchInput(c) if *adding => {
                new_dir.push(*c);
                return;
            }
            Action::SearchBackspace if *adding => {
                new_dir.pop();
                return;
            }
            // Enter: confirm new dir (when adding) OR save (when not adding)
            Action::Confirm if *adding => {
                let dir = new_dir.trim().to_string();
                if !dir.is_empty() { dirs.push(dir); }
                *adding = false;
                new_dir.clear();
                return;
            }
            Action::Confirm => {
                // Save — clone values out then dispatch
                self.handle_action(Action::SaveScanConfig);
                return;
            }
            // Esc: cancel add mode OR close popup
            Action::CancelPopup if *adding => {
                *adding = false;
                new_dir.clear();
                return;
            }
            Action::CancelPopup => {
                self.popup = None;
                return;
            }
            _ => {} // fall through to normal handling
        }
    }
    ```

    IMPORTANT: Place this block near the top of `handle_action`, BEFORE the main `match action { ... }` switch, so it intercepts actions while the ScanConfig popup is active.

    ## src/main.rs

    **1. Add `'c'` keybinding** in `remap_normal_action`:
    ```rust
    'c' => Action::OpenScanConfig,
    ```
    Add this line before `_ => Action::None`.

    **2. Add `is_scan_config_active` helper**:
    ```rust
    fn is_scan_config_active(app: &App) -> bool {
        matches!(app.popup, Some(Popup::ScanConfig { .. }))
    }
    ```

    **3. Add `remap_scan_config_action`** — maps raw key events to actions while the ScanConfig popup is open:
    ```rust
    fn remap_scan_config_action(action: Action) -> Action {
        match action {
            Action::SearchInput(c) => match c {
                'j' => Action::MoveDown,
                'k' => Action::MoveUp,
                'd' => Action::UninstallTool,
                'a' => Action::InstallTool,
                '+' => Action::SearchInput('+'),
                '-' => Action::SearchInput('-'),
                'q' | 'Q' => Action::CancelPopup,
                other => Action::SearchInput(other), // for typing in add mode
            },
            other => other,
        }
    }
    ```

    **4. Wire `remap_scan_config_action` into the event loop** — update the routing logic to check `is_scan_config_active` first:
    ```rust
    let action = if is_version_picker_active(&app) {
        remap_version_picker_action(event_action)
    } else if is_scan_config_active(&app) {
        remap_scan_config_action(event_action)
    } else if app.search_active && app.popup.is_none() {
        remap_search_action(event_action)
    } else {
        remap_normal_action(event_action)
    };
    ```
  </action>
  <verify>
    <automated>cargo build 2>&1 | grep -E "^error" | head -20</automated>
    <manual>cargo build must succeed. Check that Popup::ScanConfig is exhaustively handled in any match statements (popup.rs, app.rs).</manual>
  </verify>
  <done>cargo build succeeds. Popup::ScanConfig variant exists. MisetuiConfig::save() exists. OpenScanConfig and SaveScanConfig actions exist. 'c' is bound. Event routing includes is_scan_config_active guard.</done>
</task>

<task type="auto">
  <name>Task 2: Render scan config popup and update help text</name>
  <files>src/ui/popup.rs</files>
  <action>
    ## src/ui/popup.rs

    **1. Add match arm** in the top-level `render()` function:
    ```rust
    Popup::ScanConfig { dirs, selected, adding, new_dir, max_depth } => {
        render_scan_config(f, dirs, *selected, *adding, new_dir, *max_depth)
    }
    ```

    **2. Add `render_scan_config` function**:
    ```rust
    fn render_scan_config(
        f: &mut Frame,
        dirs: &[String],
        selected: usize,
        adding: bool,
        new_dir: &str,
        max_depth: usize,
    ) {
        use ratatui::style::Style;
        use ratatui::widgets::{ListItem, ListState};

        // Height: 3 (border+title+depth) + dirs.len() + 1 (add row) + 2 (hints) + padding
        let height = (dirs.len() as u16 + 8).max(12).min(28);
        let area = centered_rect(58, height, f.area());
        f.render_widget(Clear, area);

        let block = Block::default()
            .title(Span::styled(" Scan Config ", theme::title()))
            .borders(Borders::ALL)
            .border_type(BorderType::Rounded)
            .border_style(theme::popup_border())
            .style(theme::popup_bg());

        let inner = block.inner(area);
        f.render_widget(block, area);

        // Layout: depth row | divider | dir list | add row | hint
        let chunks = Layout::default()
            .direction(ratatui::layout::Direction::Vertical)
            .constraints([
                Constraint::Length(1), // max_depth
                Constraint::Length(1), // blank
                Constraint::Min(1),    // dir list
                Constraint::Length(1), // add row / input
                Constraint::Length(1), // blank
                Constraint::Length(1), // hints
            ])
            .split(inner);

        // Max depth row
        let depth_line = Line::from(vec![
            Span::styled("  max_depth: ", theme::key_desc()),
            Span::styled(max_depth.to_string(), theme::title()),
            Span::styled("   (-/+ to change)", theme::muted()),
        ]);
        f.render_widget(Paragraph::new(depth_line), chunks[0]);

        // Dir list
        let items: Vec<ListItem> = dirs
            .iter()
            .map(|d| ListItem::new(Span::styled(format!("  {d}"), theme::table_row())))
            .collect();

        if items.is_empty() {
            let empty = Paragraph::new(Span::styled("  (no scan dirs — add one with a)", theme::muted()));
            f.render_widget(empty, chunks[2]);
        } else {
            let list = List::new(items)
                .highlight_style(theme::table_selected())
                .highlight_symbol("▶ ");
            let mut state = ListState::default();
            state.select(Some(selected));
            f.render_stateful_widget(list, chunks[2], &mut state);
        }

        // Add row / text input
        if adding {
            let add_row = Line::from(vec![
                Span::styled("  + ", theme::key_hint()),
                Span::styled(new_dir, theme::search_input()),
                Span::styled("█", theme::search_input()),
                Span::styled("  (Enter to add, Esc to cancel)", theme::muted()),
            ]);
            f.render_widget(Paragraph::new(add_row), chunks[3]);
        } else {
            let add_hint = Paragraph::new(
                Span::styled("  a add dir   d delete   Enter save   Esc cancel", theme::muted())
            );
            f.render_widget(add_hint, chunks[3]);
        }

        // Bottom hint
        let hint = Line::from(vec![
            Span::styled("  j/k", theme::key_hint()),
            Span::styled(" navigate  ", theme::key_desc()),
            Span::styled("-/+", theme::key_hint()),
            Span::styled(" depth  ", theme::key_desc()),
            Span::styled("Enter", theme::key_hint()),
            Span::styled(" save  ", theme::key_desc()),
            Span::styled("Esc", theme::key_hint()),
            Span::styled(" cancel", theme::key_desc()),
        ]);
        f.render_widget(Paragraph::new(hint), chunks[5]);
    }
    ```

    **3. Update `render_help`** — add `c` keybinding to the Projects section:
    In the Actions section of help text, add after `"    s            Cycle sort column/order"`:
    ```rust
    "    c            Edit scan config (Projects)",
    ```
  </action>
  <verify>
    <automated>cargo build 2>&1 | grep -E "^error" | head -20</automated>
    <manual>
    Run `cargo run`. Navigate to Projects tab. Press `c`.
    Confirm:
    - Popup opens showing current scan_dirs and max_depth
    - j/k navigates the dir list (selected row highlights)
    - `d` removes highlighted dir
    - `a` enters text input mode; typing builds a path; Enter adds it to the list
    - `-`/`+` changes max_depth
    - Enter (when not adding) saves and closes popup; Projects list rescans
    - Esc closes without saving
    - Check ~/.config/misetui/config.toml was written after save
    </manual>
  </verify>
  <done>cargo build succeeds. render_scan_config() renders in popup.rs. Help text shows `c` binding. The popup is fully interactive in the running app.</done>
</task>

</tasks>

<verification>
`cargo build` exits 0. Running `cargo run`:
1. Projects tab → press `c` → scan config popup opens
2. Existing scan dirs listed, max_depth shown
3. `a` → type path → Enter → dir added to list
4. `d` → selected dir removed
5. `+`/`-` → max_depth changes
6. Enter (not adding) → saves to ~/.config/misetui/config.toml → popup closes → Projects rescans
7. Esc → closes, no file written
</verification>

<success_criteria>
- `cargo build` exits 0
- `Popup::ScanConfig` variant in app.rs
- `MisetuiConfig::save()` in config.rs
- `OpenScanConfig` and `SaveScanConfig` in action.rs
- `'c'` bound in remap_normal_action
- `is_scan_config_active` + `remap_scan_config_action` in main.rs
- `render_scan_config()` in popup.rs
- Popup correctly intercepts all nav/edit/save/cancel actions
</success_criteria>

<output>
After completion, create `.planning/phases/01-projects-tab/01-05-SUMMARY.md` following the summary template.
</output>
